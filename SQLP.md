# 과목1 제 1장
# 제 1절 관계형 데이터베이스 개요

## 1. 모델링의 이해

### 1. 모델링의 정의

 * 모델을 만들어가는 일 자체를 모델링으로 정의
 * 모델에 대한 다양한 정의
 
   1. Webster 사전
      
      * 가설적 또는 일정 양식에 맞춘 표현
      * 어떤 것에 대한 예비 표현으로, 이 표현으로부터 최종 대상이 구축되도록 하는 계획으로서 기여하는 것
    
   2. 복잡한 현실 세계를 단순화시켜 표현하는 것
   3. 사람 또는 사건에 관한 양상이나 관점을 연관된 사람이나 그룹을 위하여 명확하게 하는 것
   4. 현실 세계의 추상화된 반영
   
### 2. 모델링의 특징

 1. 추상화 : 현실 세계를 일정한 형식에 맞추어 표현하는 것
 
 2. 단순화 : 현실 세계를 약속된 규약에 의해 제한된 표기법이나 언어로 표현하는 것
 
 3. 명확화 : 누구나 이해하기 쉽게 대상에 대해 정확하게 현상을 기술하는 것 
 
 > 모델링은 현실 세계를 추상화, 단순화, 명확화하기 위해 일정한 표기법에 의해 표현하는 기법
 
### 3. 모델링의 세 가지 관점

 시스템의 대상이 되는 업무를 분석하여 정보시스템으로 구성하는 과정에서 업무의 내용과 정보 시스템의 모습을 적절한 표기법으로 표현하는 것을 모델링이라고 한다면, 모델링을 다음과 같은 세가지 관점으로 구분하여 설명 할 수 있다.
 
 1. 데이터 관점
   
    업무가 어떤 데이터와 관련이 있는지 또는 데이터 간의 관계는 무엇인지에 대해서 모델링 하는 방법 (What, Data)
    
 2. 프로세스 관점
 
    업무가 실제 하고 있는 일은 무엇인지 또는 무엇을 해야 하는지를 모델링하는 방법 (How, Data)
    
 3. 데이터와 프로세스의 상관관점
 
    업무가 처리하는 일의 방법에 따라 데이터는 어떻게 영향을 받고 있는지 모델링하는 방법 (Interaction)
    
 <br>
 
## 2. 데이터 모델의 기본 개념 이해

### 1. 데이터 모델링의 정의

 * 데이터 모델링의 정의
  
   1. 정보 시스템을 구축하기 위한 데이터 관점의 업부 분석 기법
   2. 현실 세계의 데이터에 대한 약속된 표기법에 의해 표현하는 과정
   3. 데이터베이스를 구축하기 위한 분석/설계 과정
 
 * 데이터 모델링을 하는 주요 이유
 
   1. 정보 시스템 구축의 대상이되는 업무 내용을 정확하게 분석하는 것
   2. 분석된 모델을 가지고 실제 데이터베이스를 생성하여 개발 및 데이터 관리에 사용하는 것

### 2. 데이터 모델이 제공하는 기능

 1. 시스템을 현재 또는 원하는 모습으로 가시화하도록 도와줌
 2. 시스템의 구조와 행동을 명세화 할 수 있음
 3. 시스템을 구축하는 구조화된 틀 제공
 4. 시스템을 구축하는 과정에서 결정한 것을 문서화
 5. 다양한 영역에 집중하기 위해 다른 영역의 세부 사항을 숨기는 다양한 관점 제공
 6. 특정 목적에 따라 구체화된 상세 수준의 표현 방법 제공
 
 <br>
 
## 3. 데이터 모델링의 중요성 및 유의점

### 1. 파급 효과 (Leverage)

 데이터 모델의 변경이 불가피한 상황이 발생했을 때 많은 영향 분석과 실제적인 변경 작업이 발생하게 된다.
 데이터 구조의 변경으로 인한 일련의 변경 작업은 전체 시스템 구축 프로젝트에서 큰 위험 요소로 적용하며, 이러한 이유에서 데이터 설계가 중요하다고 볼 수 있다.
 
### 2. 복잡한 정보 요구사항의 간결한 표현 (Comciseness)

 데이터 모델은 구축할 시스템의 정보 요구사항과 한계를 가장 명확하고 간결하게 표현할 수 있는 도구
 
### 3. 데이터 품질 (Data Quality)

 * 데이터는 기간이 오래되면 될수록 활용 가치가 높아지기 때문에 데이터 품질은 매우 중요
 * 데이터 품질의 문제가 야기되는 중대한 이유 중 하나는 데이터 구조의 문제
 
   1. 중복 데이터의 미정의 -> 중복
   2. 데이터 구조의 비즈니스 정의의 불충분 -> 비유연성
   3. 동일한 성격의 데이터를 통합하지 않고 분리함으로써 나타나는 데이터 불일치 -> 비일관성
   
 * 데이터 모델링을 할 때 유의점
 
   1. 중복 (Duplication)
   
      데이터베이스가 여러 장소에 같은 정보를 저장하지 않도록 유의
      
   2. 비유연성 (Inflexibility)
   
      데이터의 정의를 데이터의 사용 프로세스와 분리함으로써 애플리케이션과 데이터베이스에 중대한 변화를 일으킬 가능성을 줄임
      
   3. 비일관성 (Inconsistency)
   
      데이터 간 상호 연관 관계에 대한 명확한 정의
      
 <br>
 
## 4. 데이터 모델링의 3단계 진행

![sqlp1](https://user-images.githubusercontent.com/52366841/128974311-935dcbe6-0eb3-4cd2-ad37-4fb343accd69.PNG)

### 1. 개념적 데이터 모델링
 
 * 핵심 엔티티와 그들 간의 관계를 발견하고, 이것을 표현하기 위해 엔티티-관계 다이어그램을 생성하는 것
  
 * 개념 데이터 모델을 통해 조직의 데이터 요구를 공식화하는 것은 두 가지 중요한 기능 지원
   1. 사용자와 시스템 개발자가 데이터 요구 사항을 발견하는 것을 지원
   2. 현 시스템이 어떻게 변형되어야 하는가를 이해하는 데 유용
  
### 2. 논리적 데이터 모델링

 * 데이터베이스 설계 프로세스의 Input으로써 비즈니스 정보의 논리적인 구조와 규칙을 명확하게 표현하는 기법 또는 과정
 * 데이터 모델링 과정의 핵심
 * 이 단계에서 수행되는 중요한 활동은 정규화     
   정규화는 논리 데이터 모델 상세화 과정의 대표적인 활동으로, 논리 데이터 모델의 일관성을 확보하고 중복을 제거하여 속성들이 가장 적절한 엔티티에 배치되도록 함으로써 보다 신뢰성 있는 데이터 구조를 얻는 목적이 있다.
 * 논리 데이터 모델의 상세화: 식별자 확정, 정규화, M:M 관계 해소, 참조 무결성 규칙 정의 등
 
### 3. 물리적 데이터 모델링

 * 논리 데이터 모델이 데이터 저장소로써 어떻게 컴퓨터 하드웨어에 표현될 것인가를 다룸
 * 테이블, 칼럼 등으로 표현되는 물리적인 저장구조와 사용될 저장 장치, 자료를 추출하기 위한 접근 방법 등을 결정
 
### 4. 요약

![sqlp2](https://user-images.githubusercontent.com/52366841/128981948-7fa719bb-39d8-4f24-ab1e-356fa1f3e6d6.PNG)

 <br>
 
## 5. 프로젝트 생명주기 (Life Cycle)에서 데이터 모델링

 계획 또는 분석 단계에서 개념적 데이터 모델링, 분석 단계에서 논리적 데이터 모델링, 설계 단계에서 물리적 데이터 모델링이 수행되는데,
 현실 프로젝트에서는 개념적 모델이 생략된 개념/논리 데이터 모델링이 분석 단계 때 대부분 수행됨
 
 ![sqlp3](https://user-images.githubusercontent.com/52366841/128982791-d9976839-8a1c-4a80-9630-6688a39814c0.PNG)
 
## 6. 데이터 모델링에서 데이터 독립성의 이해

### 1. 데이터 독립성의 필요성

 * 지속적으로 증가하는 유지보수 비용을 절감하고 데이터 복잡도를 낮추며 중복된 데이터를 줄이기 위한 목적
 * 끊임없이 요구되는 사용자 요구사항에 대해 화면과 데이터베이스 간에 서로 독립성을 유지하기 위한 목적
 * 데이터 독립성 확보로 얻을 수 있는 효과
 
   1. 각 View의 독립성을 유지하면서 계층별 View에 영향을 주지 않고 변경 가능
   2. 단계별 Schema에 따라 데이터 정의어(DDL)와 데이터 조작어(DML)가 다름을 제공
   
 * 데이터 독립성을 이해하기 위해서는 3단계 구조, 독립성, 사상(Mapping) 3가지를 이해하면 됨

### 2. 데이터베이스 3단계 구조

![sqlp4](https://user-images.githubusercontent.com/52366841/128993296-039f5a30-7dc1-47bf-a0fa-c94561708890.PNG)

 * 외부 단계
   사용자와 가까운 단계, 사용자 개개인이 보는 자료에 대한 관점과 관련이 있음
   
 * 개념적 단계
   데이터 유형의 공통적인 사항을 처리하여 통합된 뷰를 스키마 구조로 디자인한 형태
   
 * 내부적 단계
   데이터가 물리적으로 저장된 방법에 대한 스키마 구조
   
### 3. 데이터 독립성 요소

 1. 외부 스키마 - 사용자 관점, 접근하는 특성에 따른 구성
 
    * View 단계
    * 여러 개의 사용자 관점으로 구성
    * 사용자 단계로써 사용자 개개인이 보는 개인적 DB 스키마
    * DB의 사용자 개개인이나 응용 프로그래머가 접근하는 DB 정의
   
 2. 개념 스키마 - 통합 관점
 
    * 개념 단계
    * 모든 사용자 관점을 통합한 조직 전체의 DB 기술
    * 모든 응용 시스템들이나 사용자들이 필요로 하는 데이터를 통합한 조직 전체의 DB 기술
    * DB에 저장되는 데이터와 그들 간의 관계를 표현한 스키마
    
 3. 내부 스키마 - 물리적 저장 구조
 
    * 내부 단계
    * DB가 물리적으로 저장된 형식
    * 물리적 장치에서 데이터가 실제적으로 저장되는 방법을 표현하는 스키마
    
### 4. 두 영역의 데이터 독립성

 1. 논리적 독립성
 
    * 개념 스키마가 변경되어도 외부 스키마에는 영향을 미치지 않도록 지원하는 것
    * 논리적 구조가 변경되어도 응용 프로그램에는 영향 없음
    * 사용자 특성에 맞는 변경 가능
    * 통합 구조 변경 가능
    
 2. 물리적 독립성
 
    * 내부 스키마가 변경되어도 외부/개념 스키마는 영향을 받지 않도록 지원하는 것
    * 저장 장치의 구조 변경은 응용 프로그램과 개념 스키마에 영향 없음
    * 물리적 구조 영향 없이 개념 구조 변경 가능
    * 개념 구조 영향 없이 물리적 구조 변경 가능
    
### 5. 사상 (Mapping)

 * 사상은 상호 독립적인 개념을 연결시켜주는 다리를 의미
 * 사상
 
   1. 외부적/개념적 사상 (논리적 사상)
   
      * 외부적 뷰와 개념적 뷰의 상호 관련성을 정의
      * 외부 화며니나 사용자에게 인터페이스 하기 위한 스키마 구조는 전체가 통합된 개념적 스키마와 연결된다는 것
      * 사용자가 접근하는 형식에 따라 다른 타입의 필드를 가질 수 있음. 개념적 뷰의 필드 타입은 변화 없음
      
   2. 개념적/내부적 사상 (물리적 사상)
   
      * 개념적 뷰와 저장된 데이터베이스의 상호 관련성 정의
      * 통합된 개념적 스키마 구조와 물리적으로 저장된 구조의 물리적인 테이블 스페이스가 연결되는 구조
      * 저장된 데이터베이스 구조가 바뀐다면 개념적/내부적 사상이 바뀌어야 함. 그래야 개념적 스키마가 그대로 남아있게 됨
      
 * 각 단계 (외부, 개념적, 내부적)의 독립성을 보장하기 위해서 변경 사항이 발생했을 때 DBA가 적절하게 작업을 해주기 때문에 독립성이 보장된다고 할 수 있음
 
 <br>
 
## 7. 데이터 모델링의 중요한 세 가지 개념

### 1. 데이터 모델링의 세 가지 요소

 1. Things
 
    * 업무가 관여하는 어떤 것
    * 전체를 지칭하는 용어
    * 엔티티
    
 2. Attributes
 
    * 어떤 것이 가지는 성격
    * 세부적인 사항
    * 속성
    
 3. Relationships
 
    * 업무가 관여하는 어떤 것 간의 관계
    * 연관성
    * 관계
    
### 2. 단수와 집합(복수)의 명명

![sqlp5](https://user-images.githubusercontent.com/52366841/129123080-fd4f4366-8f89-46a1-b39d-be1570df86e3.PNG)

 * 실무 현장에서는 엔티티를 어떤 것에 대한 집합을 명명하여 지칭하며, 개별 요소에 대해서는 인스턴스/어커런스를 사용하여 단수 개념 표현
 * 관계도 복수로 통칭하여 표현하고 이에 대한 개별 연관성을 페어링이라고 부르기도 하지만, 일반적으로 단수든 복수든 관계라고 표현
 * 어떤 것이 가지는 성격에 대한 집합 개념은 속성이고 이에 대한 개별 값들은 속성 값으로 구분
 
 <br>
 
## 8. 데이터 모델링의 이해관계자

### 1. 이해관계자의 데이터 모델링 중요성 인식

 * 실제 모델링 작업은 응용 개발을 하는 사람이나 업무 분석가가 담당하고, 모델러나 DBA는 정확하게 모델링이 진행될 수 있도록 교육하고 제시하며 현안별로 직접 모델링을 진행하는 역할 수행
 * 데이터 모델링이라는 과정이 단지 데이터베이스를 설계한다는 측면보다 업무를 이해하고 분석하여 표현하는 것이 중요하고, 표현된 내용을 바탕으로 프로젝트 관련자와 의사소통하고 프로그램이나 다른 표기법과 비교 검증하는 일을 수행하는 등 많은 시간을 업무 분석과 설계에 할애하기 때문에 업무 영역별 개발팀에서 보통 데이터 모델링 진행
 
### 2. 데이터 모델링의 이해관계자

 1. 정보 시스템을 구축하는 모든 사람 (전문적으로 코딩만 하는 사람 포함)
 2. IT 기술에 종사하거나 전공하지 않았더라도 해당 업무에서 정보화를 추진하는 위치에 있는 사람

 <br>
 
## 9. 데이터 모델의 표기법인 ERD의 이해

### 1. 데이터 모델 표기법

 이론을 배울 때 엔티티를 사각형으로, 관계를 마름모로, 속성을 타원형으로 표현하는 Entity-Relationship Model (E-R Model)을 주로 사용
 
 ![sqlp6](https://user-images.githubusercontent.com/52366841/129125442-d908b864-e36b-48b4-b820-31ea6294645c.PNG)
 
### 2. ERD (Entity Relationship Diagram) 표기법을 이용하여 모델링하는 방법

 1. ERD 작업 순서
    
    엔티티 그림 -> 엔티티 배치 -> 엔티티 간 관계 설정 -> 관계명 기술 -> 관계 참여도 기술 -> 관계 필수 여부 기술
    
 2. 엔티티 배치
 
    * 가장 중요한 엔티티를 왼쪽 상단에 배치하고 이것을 중심으로 엔티티를 나열하면 사람의 눈이 따라가기 편리한 데이터 모델링 전개 가능
    * 업무 흐름에 중심이 되는 엔티티는 중앙에 배치
    * 업무를 진행하는 중심 엔티티와 관계를 갖는 엔티티들은 중심에 배치된 엔티티 주위에 배치
    
 3. ERD 관계 연결
 
    중복된 관계가 발생하지 않도록 하고 Circle 관계도 발생하지 않도록 유의
    
 4. ERD 관계명 표시
 
    * 현재형 사용
    * 지나치게 포괄적인 용어는 사용X
    
 5. ERD 관계 차수와 선택성 표시
 
    * IE 표기법: 단일 관계는 실선, 다수 관계는 까마귀발 모양에 원
    * Barker 표기법: 단일 관계는 실선과 점선 혼합, 다수 관계는 까마귀발 모양
    
![sqlp7](https://user-images.githubusercontent.com/52366841/129126313-67aafb05-0428-412e-b554-b241266459cb.PNG)

 <br>
 
## 10. 좋은 데이터 모델의 요소

### 1. 완전성 (Completeness)

 *  업무에서 필요로 하는 모든 데이터가 데이터 모델에 정의되어 있어야 함
  
### 2. 중복 배제 (Non-Redundancy)

 * 하나의 데이터베이스 내에 동일한 사실은 반드시 한 번만 기록하여야 함
 * 예: '나이' 칼럼과 '생년월일' 칼럼이 동시에 존재한다면 이것은 데이터 중복
  
### 3. 업무 규칙 (Business Rules)

 * 데이터 모델에서 매우 중요한 요소 중 하나가 데이터 모델링 과정에서 도출되고 규명되는 수많은 업무 규칙을 데이터 모델에 표현하고 이를 해당 데이터 모델을 활용하는 모든 사용자가 공유할 수 있도록 제공하는 것
 * 해당 데이터 모델을 사용하는 모든 사용자 (개발자, 관리자 등)가 해당 규칙에 대해서 동일한 판단을 하고 데이터를 조작할 수 있게 됨
 
### 4. 데이터 재사용 (Data Reusability)

 * 데이터의 통합성과 독립성에 대해서 고려해야 함
 * 통합 모델이어야만 데이터 재사용성을 향상시킬 수 있음
 * 기업이 관리하고자 하는 데이터를 합리적으로 균형이 있으면서도 단순하게 분류하는 것이 중요

### 5. 의사소통 (Communication)

 * 데이터 모델을 대상으로 하는 업무를 데이터 관점에서 분석하고 이를 설계하여 나오는 최종 산출물
 * 도출된 많은 업무 규칙들은 데이터 모델에 엔티티, 서브타임, 속성, 관계 등의 형태로 최대한 자세하게 표현되어야 함
 
### 6. 통합성 (Integration)

 * 동일한 데이터는 조직의 전체에서 한 번만 정의되고 이를 여러 다른 영역에서 참조, 활용하는 것
 * 성능 등의 부가적인 목적으로 의도적으로 데이터를 중복시키는 경우는 존재할 수 있음
 
 <br>
 
# 제 2절 엔티티 (Entity)

## 1. 엔티티의 개념

 * 업무에 필요하고 유용한 정보를 저장하고 관리하기 위한 집합적인 것 (Thing)
 * 업무 활동상 지속적으로 관심을 가지고 있어야 하는 대상
 * 대상들 간에 동질성을 지닌 인스턴스들이나 그들이 행하는 행위의 집합 -> 인스턴스 집합
 * 인스턴스: 엔티티 하나의 값
 * 속성: 엔티티에 속하는 개체들의 특성
 
## 2. 엔티티와 인스턴스에 대한 내용과 표기법

![sqlp8](https://user-images.githubusercontent.com/52366841/129128729-ef4abb4c-17db-4c07-93ca-89f8546413d1.PNG)

<br>

## 3. 엔티티의 특징

### 1. 업무에서 필요로 하는 정보

 * 시스템을 구축하고자 하는 업무에서 필요로 하고 관리하고자 하는 정보여야 함
 * 엔티티 도출할 때 업무 영역 내에서 관리할 필요가 있는지 판단하는 것이 중요
 
### 2. 식별이 가능해야 함

 * 식별자에 의해 식별이 가능해야 함
 * 각각의 업무적으로 의미를 가지는 인스턴스가 식별자에 의해 한 개씩만 존재
 * 유일한 식별자는 그 엔티티의 인스턴스만의 고유한 이름
 
### 3. 인스턴스의 집합

 * 영속적으로 존재하는 인스턴스의 집합
 * 두 개 이상의 인스턴스
 > 엔티티 뿐만 아니라 엔티티 간의 관계, 프로세스와의 관계 등 업무를 분석하고 설계하는 동안 설계자가 모든 업무에 대입해보고 검증해봐야 할 중요한 개념
 * 하나의 엔티티는 여러 개의 인스턴스 포함
 
### 4. 업무 프로세스에 의해 이용

 * 업무 프로세스가 그 엔티티를 반드시 이용해야 함
 * 업무 프로세스에 의해 CRUD (Create, Read, Update, Delete)등이 발생하지 않는 고립된 엔티티의 경우, 엔티티를 제거하거나 누락된 프로세스가 존재하는지 살펴봐야 함
 
### 5. 속성 포함

 * 엔티티는 반드시 속성이 포함되어 있어야 함
 * 예외적으로 관계엔티티의 경우는 주식별자 속성만 가지고 있어도 엔티티로 인정
 
### 6. 관계 존재

 * 엔티티는 다른 엔티티와 최소 한 개 이상의 관계가 존재해야 함
 * 해당 업무 내에서 업무적인 연관성 (존재적, 행위적)을 가지고 다른 엔티티와 연관의 의미를 가지고 있어야 함
 * 데이터 모델링을 하면서 관계를 생략하여 표현하는 경우
   
   1. 통계성 엔티티 도출:
      통계 업무를 위해 별도로 엔티티를 다시 정의하는 경우 생략
      
   2. 코드성 엔티티 도출:
      너무 많은 엔티티와 엔티티 간의 관계 설정으로 인해 데이터 모델의 읽기 효율성이 저하되므로 생략
      
   3. 시스템 처리 시 내부 필요에 의한 엔티티 도출:
      트랜잭션이 업무적으로 연관된 테이블과 관계 설정이 필요하지만, 시스템 내부적인 필요에 의해 생성된 엔티티이므로 관계 생략
      
<br>

## 4. 엔티티의 분류

### 1. 유무형에 따른 분류

 1. 유형 엔티티 (Tangible Entity)
 
   * 물리적인 형태가 있고 안정적이며 지속적으로 활용되는 엔티티
   * 업무로부터 엔티티를 구분하기 가장 용이
   * 예: 사원, 물품, 강사 등
   
 2. 개념 엔티티 (Conceptual Entity)
 
   * 물리적인 형태는 존재하지 않고 관리해야 할 개념적 정보
   * 예: 조직, 보험 상품 등
   
 3. 사건 엔티티 (Event Entity)
 
   * 업무를 수행함에 따라 발생되는 엔티티
   * 비교적 발생량이 많으며 각종 통계 자료에 이용
   * 예: 주문, 청구, 미납 등
   
### 2. 발생 시점에 따른 분류

 1. 기본/키 엔티티 (Fundamental Entity, Key Entity)
 
   * 업무에 원래 존재하는 정보
   * 독립적으로 생성 가능
   * 타 엔티티의 부모 역할
   * 예: 사원, 부서, 고객, 상품, 자재 등
   
 2. 중심 엔티티 (Main Entity)
 
   * 기본 엔티티로부터 발생
   * 업무에 있어서 중심적인 역할
   * 데이터 양이 많이 발생되고 다른 엔티티와의 관계를 통해 많은 행위 엔티티 생성
   * 예: 계약, 사고, 예금원장, 청구, 주문, 매출 등
   
 3. 행위 엔티티 (Active Entity)
 
   * 두 개 이상의 부모 엔티티로부터 발생
   * 자주 내용이 바뀌거나 데이터량 증가
   * 예: 주문 목록, 사원 변경 이력 등
   
<br>

## 5. 엔티티의 명명

 1. 가능하면 현업 업무에서 사용하는 용어를 사용
 2. 약어를 사용하지 않음
 3. 단수 명사 사용
 4. 모든 엔티티에서 유일하게 이름이 부여
 5. 엔티티 생성 의미대로 이름 부여
 
 <br>
 
# 제 3절 속성 (Attribute)

## 1. 속성 (Attribute)의 개념

 * 업무에서 필요
 * 의미상 더 이상 분리되지 않음
 * 엔티티를 설명
 * 인스턴스의 구성요소
 
## 2. 엔티티, 인스턴스와 속성, 속성값에 대한 내용과 표기법

### 1. 엔티티, 인스턴스, 속성, 속성값의 관계

 * 한 개의 엔티티는 두 개 이상의 인스턴스의 집합이어야 함
 * 각각의 인스턴스는 속성의 집합
 * 한 개의 엔티티는 두 개 이상의 속성을 가짐
 * 한 개의 속성은 한 개의 속성값만 가짐
 
### 2. 속성의 표기법

 * 엔티티 내에 이름을 포함하여 표현
 
## 3. 속성의 특징

 * 엔티티와 마찬가지로 반드시 해당 업무에서 필요하고 관리하고자 하는 정보이어야 함
 * 정규화 이론에 근간하여 정해진 주식별자에 함수적 종속성을 가져야 함
 * 하나의 속성에는 한 개의 값만 가지며, 하나의 속성에 여러 개의 값이 있는 다중 값일 경우 별도의 엔티티를 이용하여 분리
 
## 4. 속성의 분류

### 1. 속성의 특성에 따른 분류

 1. 기본 속성
 
   * 업무로부터 추출한 모든 속성
   * 엔티티에 가장 일반적이고 많은 속성 차지
   * 코드성 데이터, 엔티티 식별을 위해 부여된 일련번호, 다른 속성을 계산하거나 영향을 받아 생성된 속성을 제외한 모든 속성이 기본 속성
   
 2. 설계 속성
 
   * 데이터 모델링을 위해, 업무 규칙화를 위해 속성을 새로 만들거나 변형하여 정의하는 속성
   * 코드성 속성, 일련번호
   
 3. 파생 속성
 
   * 다른 속성에 영향을 받아 발생하는 속성
   * 계산된 값
   * 데이터 정합성 유지를 위해 유의할 점이 많으므로 가급적 적게 정의하는 것이 좋음
   * 통계 관련 엔티티나 배치 작업이 수행되면서 발생되는 엔티티의 경우 많이 이용
   
### 2. 엔티티 구성방식에 따른 분류

 1. 속성 분류
   
   * PK (Primary Key)속성: 엔티티를 식별할 수 있는 속성
   * FK (Foreign Key)속성: 다른 엔티티와의 관계에 포함된 속성
   * 일반 속성: 엔티티에 포함되어 있고 PK, FK에 포함되지 않은 속성
   
 2. 세부 의미에 따라
 
   * 단순 속성: 나이, 성별 등과 같이 더 이상 다른 속성들로 구성될 수 없는 속성
   * 복합 속성: 주소처럼 시, 구, 동, 번지 등과 같은 여러 세부 속성들로 구성된 속성
   
 3. 속성 값에 따라
 
   * 단일 값: 속성 하나에 한 개의 값만 가지는 경우
   * 다중 값: 휴대전화처럼 집, 개인, 회사와 같은 여러 개의 값을 가지는 경우
              하나의 엔티티에 포함될 수 없으므로 1차 정규화를 하거나 별도의 엔티티를 만들어 관계로 연결해야 함
          
## 5. 도메인

 * 속성이 가질 수 있는 값의 범위
 
## 6. 속성의 명명 (Naming)

 * 해당 업무에서 사용하는 이름 부여
 * 서술식 속성명은 사용X
 * 약어 사용은 가급적 제한
 * 전체 데이터 모델에서 유일성을 확보하는 것이 좋음
 
 <br>
 
# 제 4절 관계 (Relationship)

## 1. 관계의 개념

### 1. 관계의 정의
 
 엔티티의 인스턴스 사이의 논리적인 연관성으로서 존재 또는 행위로서 서로에게 연관성이 부여된 상태
 
### 2. 관계의 페어링

 * 페어링: 엔티티 안에 인스턴스가 개별적으로 관계를 가지는 것
 * 관계 페어링: 엔티티 내 인스턴스와 인스턴스 사이에 관계가 설정되어 있는 어커런스
 * 엔티티는 인스턴스의 집합을 논리적으로 표현했다면 관계는 관계 페어링의 집합을 논리적으로 표현한 것
 
## 2. 관계의 분류
 
 어떤 목적으로 연결되었느냐에 따라 분류
 1. 존재에 의한 관계
 
    * 존재의 형태에 의해 관계가 형성되어 있는 것
    * 클래스 다이어그램의 연관관계에 해당
    * 표현방법은 실선, 소스코드에서는 멤버 변수로 선언
    
 2. 행위에 의한 관계
 
    * 행위에 의해 관계가 형성되는 것
    * 클래스 다이어그램의 의존관계에 해당
    * 표현방법은 점선, 소스코드에서 Operation(Method)의 파라미터 등으로 이용
    
## 3. 관계의 표기법

### 1. 관계명 (Membership)

 * 관계의 이름
 * 엔티티가 관계에 참여하는 형태 지칭
 * 각각의 관계는 두 개의 관계명을 가지며, 두 가지의 관점으로 표현됨
 * 엔티티에서 관계가 시작되는 편을 관계시작점이라고 부르고, 받는편을 관계끝점이라고 부름
 * 명명규칙
   1. 애매한 동사는 피하기
   2. 현재형으로 표현
   
### 2. 관계차수 (Degree/Cardinality)

 * 두 개의 엔티티 간 관계에서 참여자 수를 표현하는 것
 * 한 개가 참여하는 경우 실선, 다수가 참여하는 경우 까마귀 발과 같은 모양으로 그림
 * 관계차수
 
   1. 1:1 (One To One)
   
    * 관계에 참여하는 각각의 엔티티는 관계를 맺는 다른 엔티티에 대해 단 하나의 관계만을 가짐
    
   2. 1:M (One To Many)
   
    * 관계에 참여하는 각각의 엔티티는 관계를 맺는 다른 엔티티에 대해 하나나 그 이상의 수와 관계를 가지는데, 반대 방향은 단 하나의 관계를 가짐
    
   3. M:N (Many To Many)
   
    * 관계에 참여하는 각각의 엔티티는 관계를 맺는 다른 엔티티에 대해 하나 그 이상의 수와 관계를 가짐
    * 두 개의 주식별자를 상속받는 관계 엔티티를 이용하여 3개의 엔티티로 구분하여 표현
    
### 3. 관계선택사양 (Optionality)

 1. 필수 참여 관계
 
  * 모든 참여자가 반드시 관계를 가지며 타 엔티티의 참여자와 연결되어야 하는 관계
  
 2. 선택 참여 관계
 
  * 타 참여하는 엔티티가 항상 참여하는 것이 아닌 참여할 수 있는 관계
  * 물리속성에서 FK로 연결될 경우 Null이 허용될 수 있는 항목
  * ERD에서 관계를 나타내는 선에서 선택 참여하는 엔티티쪽을 원으로 표시 (필수 참여는 아무런 표시를 하지 않음)

## 4. 관계의 정의 및 읽는 방법

### 1. 관계 체크사항

 * 두 개의 엔티티 사이에 관심있는 연관규칙이 존재하는가?
 * 두 개의 엔티티 사이에 정보의 조합이 발생되는가?
 * 업무기술서, 장표에 관계연결에 대한 규칙이 서술되어 있는가?
 * 업무기술서, 장표에 관계연결을 가능하게 하는 동사(Verb)가 있는가?
 
### 2. 관계 읽기

 * 기준 엔티티를 한 개 또는 각으로 읽기
 * 대상 엔티티의 관계참여도 즉 개수(하나, 하나 이상)읽기
 * 관계선택사양과 관계명 읽기
 
 <br>
 
# 제 5절 식별자

## 1. 식별자 (Identifiers) 개념

 * 엔티티 내에서 인스턴스들을 구분할 수 있는 구분자
 * 하나의 엔티티에 구성되어 있는 여러 개의 속성 중 엔티티를 대표할 수 있는 속성
 * 하나의 엔티티는 반드시 하나의 유일한 식별자가 존재

## 2. 식별자의 특징

 1. 유일성: 주식별자에 의해 엔티티 내에 모든 인스턴스들을 유일하게 구분함
 2. 최소성: 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야 함
 3. 불변성: 주식별자가 한 번 특정 엔티티에 지정되면 그 식별자의 값은 변하지 않아야 함
 4. 존재성: 주식별자가 지정되면 반드시 데이터 값이 존재(Null 불가)
 
## 3. 식별자 분류 및 표기법

### 1. 식별자 분류

![sqlp9](https://user-images.githubusercontent.com/52366841/129670609-5b44069a-b071-4767-bb64-6ebe5a6aee1e.PNG)

### 2. 식별자 표기법

![sqlp10](https://user-images.githubusercontent.com/52366841/129671080-7a8ade40-db2d-42f3-b80f-e5a36bf704b4.PNG)

## 4. 주식별자 도출기준

 1. 해당 업무에서 자주 이용되는 속성을 주식별자로 지정하도록 함
 2. 명칭, 내역 등과 같이 이름으로 기술되는 것은 피함
 3. 속성의 수가 많아지지 않도록 함

## 5. 식별자 관계와 비식별자 관계에 따른 식별자

### 1. 식별자 관계와 비식별자 관계의 결정

 * 외부 식별자
   * 다른 엔티티와의 관계를 통해 자식 쪽의 엔티티에 생성되는 속성
   * Foreign Key 역할
 * 자식 엔티티에서 부모 엔티티로부터 받은 외부 식별자를 주식별자로 이용할 것인지 아니면 부모와 연결되는 속성으로만 이용할 것인지 결정해야 함
 
### 2. 식별자 관계

 * 자식 엔티티의 주식별자로 부모의 주식별자가 상속되는 경우
 * 자식 엔티티에서 부모 엔티티의 속성만 주식별자로 사용한다면 1:1 관계, 부모 엔티티의 속성 외에 다른 속성과 함계 주식별자로 구성되는 경우 1:M 관계

### 3. 비식별자 관계

 * 부모 엔티티로부터 속성을 받았지만 자식 엔티티의 주식별자로 사용하지 않고 일반적인 속성으로만 사용하는 경우
 * 비식별자 관계에 의한 외부속성을 생성하는 경우
 
   1. 자식 엔티티에서 받은 속성이 반드시 필수가 아니어도 무방하기 때문에 부모 없는 자식이 생성될 수 있는 경우
   2. 엔티티별로 데이터의 생명주기를 다르게 관리할 경우
   3. 여러 개의 엔티티가 하나의 엔티티로 통합되어 표현되었는데 각각의 엔티티가 별도의 관계를 가지는 경우
   4. 자식 엔티티에 주식별자로 사용하여도 되지만 자식 엔티티에서 별도의 주식별자를 생성하는 것이 더 유리하다고 판단되는 경우

### 4. 식별자 관계로만 설정할 경우의 문제점

 식별자 관계만으로 연결된 데이터 모델의 특징은 주식별자 속성이 지속적으로 증가할 수 밖에 없는 구조라는 점인데, 이것은 개발 복잡성 및 오류 가능성을 유발시킬 수 있는 요인임
 
### 5. 비식별자 관계로만 설정할 경우의 문제점

 비식별자 관계로만 데이터 모델링을 전개하다 보면 SQL 구문에 많은 조인이 걸리게 되고 그에 따라 복잡성이 증가하고 성능이 저하됨
 
### 6. 비식별자 관계와 비식별자 관계 모델링

 1. 비식별자 관계 선택 프로세스
    
    기본적으로 식별자 관계로 모든 관계가 연결되면서 다음 조건에 해당할 경우 비식별자 관계로 조정하면 됨
    
    ![sqlp11](https://user-images.githubusercontent.com/52366841/129675690-5de41014-3c27-4abe-913b-914297578789.PNG)
    
 2. 식별자와 비식별자 관계 비교
 
 ![sqlp12](https://user-images.githubusercontent.com/52366841/129675866-012a6504-5ab7-4e01-bbe5-909962b12609.PNG)
 
 <br>
 
# 과목1 제 2장
# 제 1절 성능 데이터 모델링의 개요

## 1. 성능 데이터 모델링의 정의

 * 성능이 저하되는 경우
 
   1. 데이터 모델 구조
   2. 대용량 데이터
   3. 인덱스 특성을 충분히 고려하지 않은 인덱스 생성
   
 * 성능 데이터 모델:
 
   데이터베이스 성능향상을 목적으로 설계 단계의 데이터 모델링 때부터 정규화, 반정규화, 테이블 통합, 테이블 분할, 조인 구조, PK, FK 등 여러 가지 성능과 관련된 사항이 데이터 모델링에 반영될 수 있도록 하는 것
   
## 2. 성능 데이터 모델링 수행시점

 성능 향상을 위한 비용은 프로젝트 수행 중에 있어서 사전에 할 수록 비용이 들지 않음
 
## 3. 성능 데이터 모델링 고려사항

 1. 데이터 모델링을 할 때 정규화 정확하게 수행
 2. 데이터베이스 용량산정 수행
 3. 데이터베이스에서 발생되는 트랜잭션 유형 파악
 4. 용량과 트랜잭션 유형에 따라 반정규화 수행
 5. 이력 모델의 조정, PK/FK 조정, 슈퍼타입/서브타입 조정 등 수행
 6. 성능 관점에서 데이터 모델 검증

 <br>
 
# 제 2절 정규화와 성능

## 1. 정규화를 통한 성능 향상 전략

 * 정규화를 하는 것은 기본적으로 데이터에 대한 중복성을 제거하여 주고 데이터가 관심사별로 처리되는 경우가 많기 때문에 성능이 향상되는 특징이 있음
 * 일반적으로 정규화를 수행해야 데이터 처리(입력, 수정, 삭제)의 성능이 향상되며 데이터 조회 처리 트랜잭션 시 성능저하가 나타날 수 있음
 * 반정규화만이 조회 성능을 향상시키는 것은 아니며, 상황에 따라 정규화를 해야만 성능이 향상되는 경우도 많음
 
## 2. 반정규화된 테이블 성능저하 사례

 * 2차 정규화를 적용한 테이블에 대해서 조인을 하더라도 PK Unique Index를 이용하면 조인 성능 저하가 미미하게 발생하며, 상황에 따라서 조회가 더 빠르게 이루어짐
 * 대량의 데이터에서 조인 조건이 되는 대상을 찾기 위해 인라인뷰를 사용하면 성능이 저하됨 -> 2차 정규화 필요
 * 동일한 속성 형식을 두 개 이상의 속성으로 나열한 반정규화의 경우 한 테이블에 인덱스가 많아져 조회 성능은 향상되지만 데이터 입력/수정/삭제 성능은 저하됨 -> 1차 정규화 필요

## 3. 함수적 종속성 (Functional Dependency)에 근거한 정규화 수행 필요

 * 함수적 종속성: 테이블들이 어떤 기준값에 의해 종속되는 현상
 * 결정자 (Determinant): 기준값
 * 종속자 (Dependent): 종속되는 값
 * 데이터는 속성 간의 함수적 종속성에 근거하여 정규화되어야 하며, 프로젝트 수행에서 정규화는 필수사항
 
 <br>
 
# 제 3절 반정규화와 성능

## 1. 반정규화를 통한 성능향상 전략

### 1. 반정규화의 정의

 * 역정규화
  (비정규화는 아예 정규화를 수행하지 않는 모델)
 * 데이터를 중복하여 성능을 향상시키기 위한 기법
 * 정규화된 데이터 모델에서 중복, 통합, 분리 등을 수행하는 모든 과정
 * 중복성의 원리를 활용하여 데이터 조회 시 성능을 향상시키는 역할
 * 설계 단계에서 반정규화를 기술적으로 수행하지 않는 경우 나타나는 문제
   
   1. 성능이 저하된 데이터베이스가 생성될 수 있음
   2. 구축 단계나 시험 단계에서 반정규화를 적용할 때 수정에 따른 노력 비용이 많이 듦

### 2. 반정규화의 적용 방법

 1. 반정규화 대상 조사
 
    * 범위 처리 빈도수 조사
    * 대량의 범위 처리 조사
    * 통계성 프로세스 조사
    * 테이블 조인 개수 조사
    
 2. 다른 방법 유도 검토
 
    * 뷰(View) 테이블
    * 클러스터링 적용
    * 인덱스 조정
    * 응용 애플리케이션

 3. 반정규화 적용
 
    * 테이블 반정규화
    * 속성의 반정규화
    * 관계의 반정규화
 
## 2. 반정규화의 기법

### 1. 테이블 반정규화

![sqlp13](https://user-images.githubusercontent.com/52366841/129823318-7b242c78-1d29-42bc-acbe-33237b38db45.PNG)

### 2. 칼럼 반정규화

![sqlp14](https://user-images.githubusercontent.com/52366841/129823361-86fcf0c3-083a-47f6-958d-55bc280d60f7.PNG)

### 3. 관계 반정규화

![sqlp15](https://user-images.githubusercontent.com/52366841/129823404-560c0ab2-44f3-45da-897c-0462d70c4613.PNG)

## 3. 정규화가 잘 정의된 데이터 모델에서 성능이 저하될 수 있는 경우

 * 1:M 관계로 복잡한 조인이 발생하는 경우
 * 분산되어 있는 서버 간 DB LINK 조인이 발생하는 경우
 
 <br>
 
# 제 4절 대량 데이터에 따른 성능

## 1. 대량 데이터 발생에 따른 테이블 분할 개요

 * 대량의 데이터가 존재하는 테이블에 많은 트랜잭션이 발생하여 성능이 저하되는 테이블 구조에 대해 수평/수직 분할 설계를 통해 성능 저하를 예방할 수 있음
 * 한 테이블에 데이터가 대량으로 집중되거나 하나의 테이블에 여러 칼럼이 존재하여 디스크에 많은 블록을 점유하는 경우 성능 저하 유발
 * 대량의 데이터가 처리되는 테이블의 성능 저하 원인은 SQL문장에 데이터를 처리하기 위한 I/O의 양 증가
 * 많은 칼럼은 로우체이닝과 로우마이그레이션이 많아지게 되어 성능이 저하됨
 
## 2. 한 테이블에 많은 수의 칼럼을 가지고 있는 경우

 * 트랜잭션이 발생될 때 어떤 칼럼에 대해 집중적을 발생하는지 분석하여 테이블을 쪼개어주면 디스크 I/O가 감소하게 되어 성능이 개선됨
 * 분리된 테이블은 디스크에 적어진 칼럼이 저장되므로 로우마이그레이션과 로우체이닝이 많이 줄어듦
 * 트랜잭션을 분석하여 적절하게 1:1관계로 분리함으로써 성능 향상 가능
 
## 3. 대량 데이터 저장 및 처리로 인한 성능

 * 테이블에 많은 양의 데이터가 예상될 경우 파티셔닝을 적용하거나 PK에 의해 테이블을 분할하는 방법 적용 가능
 * 논리적으로는 하나의 테이블로 보이지만 물리적으로 여러 개의 테이블 스페이스에 쪼개어 저장될 수 있는 구조
 
### 1. Range Partition 적용

 * 하나의 테이블에 너무 많은 데이터가 존재하여 성능이 느려진 경우 주로 적용
 * 날짜 또는 숫자값 분리
 * 각 영역별 트랜잭션 분리
 * 데이터 보관 주기에 따라 테이블 데이터를 쉽게 지울 수 있음 (파티션 테이블 drop)
 
### 2. List Partition 적용

 * PK로 구성되어 있고 대량의 데이터가 있는 테이블의 경우 각각의 값에 의해 파티셔닝되는 List Partition 적용
 * 대용량 데이터를 특정 값에 따라 분리 저장 가능
 * 데이터 보관 주기에 따른 삭제 기능 제공 X

### 3. Hash Partition 적용

 * 지정된 Hash 조건에 따라 해쉬 알고리즘이 적용되어 테이블 분리
 * 성능 향상을 위해 사용
 * 데이터 보관 주기에 따른 삭제 기능 제공 X
 
### 4. 테이블에 대한 수평분할/수직분할의 절차

 1. 데이터 모델링 완성
 2. 데이터베이스 용량 산정
 3. 대량 데이터가 처리되는 테이블에 대해 트랜잭션 처리 패턴 분석
 4. 집중화된 처리가 칼럼 단위로 발생되는지, 로우 단위로 발생되는지 분석하여 집중화된 단위로 테이블을 분리하는 것을 검토
 
 <br>
 
# 제 5절 데이터베이스 구조와 성능

## 1. 슈퍼타입/서브타입 모델의 성능 고려 방법

### 1. 슈퍼/서브타입 데이터 모델 개요

 * 슈퍼/서브타입 데이터 모델은 Extended ER 모델이라고도 함
 * 데이터 특징을 공통과 차이점을 고려하여 효과적으로 표현할 수 있어 자주 쓰임
 * 공통 부분을 슈퍼타입으로 모델링하고 공통으로부터 상속받아 다른 엔티티와 차이가 있는 속성에 대해 별도의 서브엔티티로 구분하여 업무의 모습을 정확하게 표현
 * 물리적인 데이터 모델로 변환할 때 선택의 폭을 넓힐 수 있음
 * 분석단계에서 많이 쓰이는 모델
 
### 2. 슈퍼/서브타입 데이터 모델의 변환 시 성능이 저하되는 경우

 1. 트랜잭션은 항상 일괄로 처리하는데 테이블은 개별로 유지되어 Union 연산에 의해 성능이 저하될 수 있음
 2. 트랜잭션은 항상 서브타입을 개별로 처리하는데 테이블은 하나로 통합되어 있어 불필요하게 많은 양의 데이터가 집약되어 있는 경우
 3. 트랜잭션은 항상 슈퍼+서브 타입을 공통으로 처리하는데 개별로 유지되어 있거나 하나의 테이블로 집약되어 있는 경우
 
### 3. 슈퍼/서브타입 데이터 모델의 변환 기술

 1. 개별로 발생되는 트랜잭션에 대해서는 개별 테이블로 구성
 2. 슈퍼타입+서브타입에 대해 발생되는 트랜잭션에 대해서는 슈퍼타입+서브타입 테이블로 구성
 3. 전체를 하나로 묶어 트랜잭션이 발생할 때는 하나의 테이블로 구성
 
### 4. 슈퍼/서브타입 데이터 모델 변환 타입 비교

![sqlp16](https://user-images.githubusercontent.com/52366841/130571231-cd2a142d-d657-43a4-987c-4caa177b9d20.PNG)

## 2. 인덱스 특성을 고려한 PK/FK 데이터베이스 성능 향상

### 1. PK/FK 칼럼 순서와 성능 개요

 * 인덱스: 데이터를 조회할 때 가장 효과적으로 처리될 수 있도록 접근 경로를 제공하는 오브젝트
 * 데이터베이스 테이블에서는 균형 잡힌 트리 구조인 B Tree 구조를 많이 사용
 * PK는 해당 테이블의 데이터를 접근할 때 가장 빈번하게 사용되는 유일한 인덱스를 모두 자동 생성
 * 데이터 모델링 때 결정한 PK 순서와 다르게, DDL 문장을 통해 PK 순서를 다르게 생성할 수 있음
 * FK라고 하더라도 데이터 조회 시 조인 경로를 제공하는 역할을 수행하므로 인덱스 생성 필수
 
### 2. PK 칼럼의 순서를 조정하지 않으면 성능 저하가 발생하는 이유

 PK 순서를 인덱스 특징에 맞게 고려하지 않고 그대로 생성하게 되면 테이블에 접근하는 트랜잭션의 특징에 효율적이지 않은 인덱스가 생성되어 인덱스 범위가 넓어지거나 Full Scan을 유발하게 되어 성능이 저하됨
 
### 3. PK 순서를 잘못 지정하여 성능이 저하된 경우 - 간단한 오류

 데이터가 200만건 존재하는 학원 수강생에 대한 테이블을 수험번호+년도+학기로 구성한 경우 -> Full Table Scan 발생
 ##### 년도+학기+수험번호 순으로 인덱스를 수정하면 평균 2만건 데이터 처리
 
### 4. PK 순서를 잘못 지정하여 성능이 저하된 경우 - 복잡한 오류

 사무실의 거래 내역을 저장한 테이블에 대해 거래일자+사무실 코드로 구성한 경우
 특정 날짜에 대한 특정 사무실의 거래 내역을 받아올 때 모든 사무실의 거래 내역을 받아온 후 특정 사무실의 거래 내역을 찾으므로 넒은 범위 조회로 인한 성능 저하 발생
 ##### 사무실코드+거래일자로 구성한 경우 특정 사무실을 먼저 받아온 후 거래 날짜를 찾으므로 조회 범위가 좁아져 성능이 향상됨
 
### 3. 물리적인 테이블에 FK 제약이 걸려있지 않을 경우 인덱스 미생성으로 인한 성능 저하

 * FK 인덱스를 적절하게 설계하여 구축하지 않았을 경우 데이터량이 누적됨에 따라 SQL 성능이 나빠져 데이터베이스 서버에 심각한 장애 현상을 초래하는 경우가 많음
 * 물리적인 테이블에 FK 제약을 걸었을 때 반드시 FK 인덱스 생성
 * FK 제약이 걸리지 않았을 때 FK 인덱스 생성은 기본 정책으로 하되 거의 활용되지 않을 경우 FK 인덱스를 지우는 것이 좋음
 
 <br>
 
# 제 6절 분산 데이터베이스와 성능

## 1. 분산 데이터베이스 정의

 * 여러 곳으로 분산되어있는 데이터베이스를 하나의 가상 시스템으로 사용할 수 있도록 한 데이터베이스
 * 논리적으로 동일한 시스템에 속하지만 컴퓨터 네트워크를 통해 물리적으로 분산되어 있는 데이터들의 모임 (물리적 site 분산, 논리적 사용자 통합 및 공유)
 * 데이터베이스를 연결하는 빠른 네트워크 환경을 이용하여 데이터베이스를 여러 지역 여러 노드로 위치시켜 성능, 사용성 등을 극대화시킨 데이터베이스
 
## 2. 분산 데이터베이스의 투명성 (Transparency)

 1. 분할 투명성(단편화): 하나의 논리적 Relation이 여러 단편으로 분할되어 각 단편의 사본이 여러 site에 저장
 2. 위치 투명성: 사용하려는 데이터의 저장 장소 명시 불필요 위치 정보가 System Catalog에 유지되어야 함
 3. 지역사상 투명성: 지역 DBMS와 물리적 DB 사이의 Mapping 보장 각 지역 시스템 이름과 무관한 이름 사용
 4. 중복 투명성: DB 객체가 여러 site에 중복되어 있는지 알 필요가 없는 성질
 5. 장애 투명성: 구성요소 (DBMS, Computer)의 장애에 무관한 Transaction의 원자성 유지
 6. 병행 투명성: 다수 Transaction 동시 수행 시 결과의 일관성 유지, Time Stamp, 분산 2단계 Locking을 이용하여 구현

## 3. 분산 데이터베이스의 적용 방법 및 장단점

### 1. 분산 데이터베이스 적용 방법

 * 업무의 흐름을 보고 업무 구성에 따른 아키텍처 특징에 따라 데이터베이스를 구성
 
### 2. 분산 데이터베이스 장단점

 ![sqlp1](https://user-images.githubusercontent.com/52366841/130729710-e0d4043d-2cfa-40ba-9925-abfa6e982d53.PNG)

## 4. 분산 데이터베이스의 활용 방향성

 업무적인 특징에 따라 분산 데이터베이스를 활용하는 기술 필요
 
 ![sqlp2](https://user-images.githubusercontent.com/52366841/130730297-bfe441ce-6a67-4119-8064-9c6743c7f997.PNG)
 
## 5. 데이터베이스 분산 구성의 가치

 통합된 데이터베이스에서 제공할 수 없는 빠른 성능 제공
 
 ![sqlp3](https://user-images.githubusercontent.com/52366841/130730392-435a7dd7-69e1-424d-9aff-11f960384cc7.PNG)

## 6. 분산 데이터베이스의 적용 기법

### 1. 테이블 위치 분산

 * 설계된 테이블의 위치를 각각 다르게 위치시키는 것
 * 위치별로 정보를 이용하는 형태가 다를 경우 이용
 * 테이블의 구조는 변하지 않음
 * 테이블이 다른 데이터베이스에 중복되어 생성되지 않음
 * 테이블 위치를 파악할 수 있는 도식화된 위치별 데이터베이스 문서 필요
 
 ![sqlp4](https://user-images.githubusercontent.com/52366841/130731099-8b55dcc9-ad3a-4edb-97cc-32400fff1690.PNG)
 
### 2. 테이블 분할 분산

##### 1. 수평 분할

 * 특정 칼럼의 값을 로우(Row) 단위로 분리
 * 칼럼은 분리X
 * 모든 데이터가 각 지사별로 분리되어 있는 형태
 * 데이터를 한 군데 집합시켜도 PK에 의한 중복이 발생되지 않음
 * 한 시점에 한 지사에서 하나의 데이터만 존재하므로 데이터 무결성 보장
 * 데이터 수정 시 타 지사에 있는 데이터를 원칙적으로 수정하지 않고 자신의 데이터에 대해서만 수정
 * 통합 처리 프로세스가 많은 경우 조인으로 인한 성능 저하 발생
 
 ![sqlp5](https://user-images.githubusercontent.com/52366841/130732765-ad2f79d0-7ffd-49e7-8f15-ac6f9d8bce83.PNG)
 
##### 2. 수직 분할

 * 테이블 칼럼을 기준으로 분리
 * 로우 단위 분리X
 * 모든 데이터가 각 지사별로 분리되어 있는 형태
 * 각각의 테이블에 동일한 PK 구조와 값을 가지고 있어야 함
 * 데이터 중복은 발생되지 않음
 * 통합 처리 프로세스가 많은 경우 조인으로 인한 성능 저하 발생
 
 ![sqlp6](https://user-images.githubusercontent.com/52366841/130733160-1f9aeea0-6a29-4936-986c-f4de7df2321a.PNG)
 
### 3. 테이블 복제 분산

##### 1. 부분 복제

 * 테이블의 일부 내용만 다른 지역이나 서버에 위치시킴
 * 통합된 테이블을 한 군데에 가지고 있으면서 각 지사별로 지사에 해당된 로우를 가지고 있는 형태
 * 본사의 데이터 = 지사 데이터의 합
 * 여러 테이블에 조인이 발생하지 않는 빠른 작업 수행 가능
 * 본사와 지사 간 데이터 중복이 항상 발생
 * 복사 작업은 야간에 배치 작업에 의해 수행되는 경우가 많음
 
 ![sqlp7](https://user-images.githubusercontent.com/52366841/130734345-aadf0f4c-8784-4917-904d-fe93a7ae86f4.PNG)
 
##### 2. 광역 복제

 * 테이블의 내용을 각 지역이나 서버에 존재시킴
 * 통합된 테이블을 본사에서 가지고 있으면서 각 지사에도 동일한 데이터를 모두 가지는 형태
 * 모든 지사에 있는 데이터량과 본사에 있는 데이터량 동일
 * 데이터 처리에 특별한 제약을 받지 않음
 * 복사 작업은 야간에 배치 작업에 의해 수행되는 경우가 많음
 
 ![sqlp8](https://user-images.githubusercontent.com/52366841/130735140-db8847e8-e6eb-49e4-b116-ea839b80544a.PNG)
 
### 4. 테이블 요약 분산

##### 1. 분석 요약

 * 동일한 테이블 구조를 가지고 있으면서 분산되어 있는 동일한 내용의 데이터를 이용해 통합된 데이터를 산출하는 방식
 * 각 지사별로 존재하는 요약 정보를 본사에 통합하여 다시 전체에 대해 요약 정보를 산출하는 방법
 * 야간에 수행하여 생성
  
 ![sqlp9](https://user-images.githubusercontent.com/52366841/130735849-c0a08309-201a-4c76-a599-b02d4d3c6afb.PNG)

##### 2. 통합 요약

 * 분산되어 있는 다른 내용의 데이터를 이용하여 통합된 데이터를 산출하는 방식
 * 각 지사별로 존재하는 다른 내용의 정보를 본사에 통합하여 다시 전체에 대해 요약 정보를 산출하는 방법
 * 야간에 수행하여 생성
 
 ![sqlp10](https://user-images.githubusercontent.com/52366841/130737061-e81a4815-d2f9-4eb3-8687-a4ea8a5a8bf3.PNG)
 
## 7. 분산 데이터베이스를 적용하면 성능이 향상되는 경우

 * 성능이 중요한 사이트
 * 공통 코드, 기준 정보, 마스터데이터 등에 대해 분산 환경 구성
 * 실시간 동기화가 요구되지 않을 때
 * 특정 서버에 집중이 부하될 때
 * 백업 사이트를 구성할 때
 
<br>

# 과목2 제 1장
# 제 1절 관계형 데이터베이스 개요

## 1. 데이터베이스

### 1. 데이터베이스 정의


    
 





































