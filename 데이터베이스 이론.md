# Database 이론

* [관계형 DB에서의 관계](#관계형-DB에서의-관계)

* [Connection pool](#Connection-pool)

* [데이터베이스 시스템 개요](#데이터베이스-시스템-개요)

* [DB 설계 개요](#DB-설계-개요)
  
* [ER 모델 개념적 설계](#ER-모델-개념적-설계)
  
* [관계 모델 논리적 설계](#관계-모델-논리적-설계)

* [트랜잭션(transaction)과 ACID 특성을 보장하는 방법](#트랜잭션(transaction)과-ACID-특성을-보장하는-방법)

* [신뢰성과 회복(Recovery)](#신뢰성과-회복(Recovery))

* [뷰(View)](#뷰(View))

* [정규화 (Normalization)](#정규화 (Normalization))
 
* [인덱스(Index)](#인덱스(Index))
 
</br>

## :bulb: 관계형 DB에서의 관계

 관계형 데이터베이스( MySQL, Oracle, MS-SQL, SQLite 등 )는 엔티티(객체)끼리 관계를 맺을 수 있어서 관계형 DB라는 이름이 붙었습니다. 관계는 두 엔티티가 서로 관련이 있을 때를 말하는데, 다음과 같은 관계를 맺을 수 있습니다.
 * 일대일 (1:1)
 * 일대다 (1:N)
 * 다대다 (N:M)
 
### 1. 일대일 관계(1:1)

   1 : 1 관계란 어느 엔티티 쪽에서 상대 엔티티를 보더라도 반드시 단 하나씩 관계를 가지는 것을 말합니다.
  
   예를 들면, 우리나라에서 결혼제도는 일부일처제입니다.
  즉, 한 남자는 한 여자와, 한 여자는 한 남자와 밖에 결혼을 할 수 없습니다. 
  법적으로 남편을 또는 부인을 2명 이상 둘 수 없습니다.
  이러한 관계를 1:1 관계라고 합니다.
  
  <br>
  
### 2. 일대다 관계(1:N)
  
   1 : M 관계는 한 쪽 엔티티가 관계를 맺은 엔티티 쪽의 여러 객체를 가질 수 있는 것을 의미합니다.
  이 관계는 매우 흔한 방식이며, 실제 DB를 설계할 때 자주 쓰이는 방식입니다.
  
   예를 들면, 부모와 자식 관계라고 생각하시면 됩니다.
  부모는 자식을 1명만 낳을 수도 있고, 2명, 3명, 4명, 10명 그 이상도 낳을수 있습니다.
  DB에서는 이를 부모가 자식을 소유한다고 (has a 관계) 표현합니다.
  반대로 자식 입장에서는 부모(어머니, 아버지의 쌍)를 하나만 가질 수 밖에 없습니다.
  이러한 관계를 1 : N 관계라고 하며, 계층적인 구조로 이해할 수도 있습니다.
  
  <br>
  
### 3. 다대다 관계(N:M)

   N : M 관계는 관계를 가진 양쪽 엔티티 모두에서 1 : M 관계가 존재할 때 나타나는 모습입니다.
  즉, 서로가 서로를 1:N 관계로 보고 있는 것입니다.
  
   예를 들면, 쇼핑몰에서 회원과 상품이 관계를 맺을 수 있습니다.
  한 회원은 쇼핑몰의 여러 상품들을 가질 수 있습니다.
  청바지, 모자, 티셔츠, 남방 등 다 제가 가질 수 있죠.
  반대로 한 티셔츠도 여러 회원들을 가질 수 있습니다.
  하나의 티셔츠를 나도 친구도 부모님도 가질 수 있습니다.
  이처럼 관계를 맺은 두 엔티티가 서로 많이 가질 수 있을 때, 이를 N : M 관계라고 합니다.
  
  <br>
  
### 4. 대표키와 외래키

   table을 각 엔티티를 식별할 수 있는 대표 키(PK, Primary key)가 존재합니다.
  대표키는 중복되지 않는 값입니다. (unique)
  
   예를 들어, 주민 번호는 대한민국 국민들을 식별할 수 있는 대표 키가 됩니다.
  주민등록증이 같은 사람은 있을 수 없기 때문에, 대표 키로서 기능을 할 수 있습니다.
  
  <br>
  
  #### 테이블간의 관계를 맺을 때, 흔히 대표키를 이용하여 관계를 맺습니다.
   예를 들어, 1 : N 관계의 대표적인 예로 게시글과 댓글을 생각해보겠습니다.
  게시글은 여러 댓글들을 가지고 있으며, 댓글은 어떤 한 게시글에만 속해 있습니다.
  따라서 게시글과 댓글은 1:N 관계라 할 수 있습니다.
  
   게시글은 자신이 어떤 댓글들을 가지고 있는지 어떻게 알 수 있을까요?
  댓글 테이블을 설계할 때 컬럼에는 아래와 같은 정보들이 있을 수 있습니다.
  
  * 댓글 아이디(PK)
  * 작성자 명
  * 내용
  * 작성일
  
   여기서 어떤 게시글에 속해 있는지에 대한 정보가 필요하므로 하나의 컬럼이 더 필요한데, 이를 외래키( FK, Foreign key )라 합니다.
  
  * 게시글 아이디(FK)

   여기서 게시글 아이디는 게시글 테이블의 대표 키이며, 이를 댓글 테이블의 외래키로 지정하여 관계를 맺을 수 있습니다.
  
   즉, 게시글은 어떤 댓글들이 자신의 댓글들인지 알 필요 없고, 댓글만 자신이 어떤 게시글에 속하는지만 알면 1:N 관계를 성립할 수 있습니다.
  그 역할이 외래키인 것이죠.

   그렇다면 N:M 관계에서는 어떨까요?
  여기서는 서로가 서로를 1:M , 1:N  관계로 갖고 있기 때문에, 서로의 PK가 자신의 외래키 컬럼으로 갖고 있으면 됩니다.
  일반적으로 N:M 관계는 두 테이블의 대표키를 컬럼으로 갖는 또 다른 테이블을 생성해서 관리합니다.
  
  [ 참고자료 ] <http://www.dbguide.net/db.db?cmd=view&boardUid=12851&boardConfigUid=9&categoryUid=216&boardIdx=40&boardStep=1>

  
  <br>
  
## :bulb: Connection pool
  
### 1. 커넥션 풀(Connection pool)

  커넥션 풀이란 DB와 미리 connection( 연결 )을 해놓은 객체들을 pool( 웅덩이 )에 저장해두었다가, 클라이언트 요청이 오면 커넥션을 빌려주고, 볼일이 끝나면 다시 커넥션을 반납받아 pool에 저장하는 방식을 말합니다.
    
  ![connection](https://user-images.githubusercontent.com/52366841/126592139-6cb3b358-9bf1-426b-8016-0d45ef37fef9.PNG)
    
  클라이언트가 DB와 연결이 필요할 때, connection pool에서 connection을 빌려와 DB에 접근해서 쿼리를 날린 후, 볼 일이 끝나면 사용했던 connection을 다시 pool에 반납을 하는 과정을 표현했습니다.
  
<br>
    
### 2. 특징 / 장단점

 예를 들어, 게시판 웹 애플리케이션을 가정해보겠습니다. 어떤 유저가 게시글을 작성하는 과정을 보면, 그 과정은 다음과 같습니다.
 
 1. 클라이언트가 서버로 게시글 데이터를 전달
 2. 비즈니스 로직 처리
 3. DB와 커넥션을 맺은 후, DB에 게시글 데이터를 저장
 4. DB와 커넥션을 끊고, 비즈니스 로직 처리
 5. 클라이언트에 응답
 
 그런데 서비스가 커져서 유저가 한 명이 아니라, 100명의 유저가 동시에 접속 중이라고 가정해보겠습니다.
위와 같은 경우 매번 DB와 커넥션을 맺고 끊는 과정이 필요한데 커넥션 풀을 사용하게 되면, 미리 연결을 맺고 있는 커넥션들이 있기 때문에 커넥션을 맺고 끊는 과정이 불필요합니다.
즉, DB 접근 시 불필요한 작업(커넥션 생성, 끊기)이 사라지므로 성능향상을 기대할 수 있습니다.

 DB에서는 기본적으로 커넥션을 일정량 제공해줍니다.
그런데 유저가 많아져서 커넥션이 모자랄 경우, 즉 기본으로 제공된 커넥션이 모자랄 경우 원활한 서비스가 이루어지지 않습니다.
커넥션이 반납될 때까지 기다려야 하기 때문이죠. 따라서 유저수에 따라 커넥션을 조절할 필요가 있습니다.

 그렇다고 커넥션을 막 늘리는 것은 좋지 않습니다.
컴퓨터 세계에서는 항상 trade off가 있듯이, 커넥션 풀을 통한 장점도 있지만 단점도 있습니다.
커넥션 또한 객체이므로 메모리를 차지하게 됩니다.
따라서 무작정 많이 늘리는 것은 메모리를 많이 차지하게 되므로 오히려 성능이 떨어지는 결과를 가져옵니다.

<br>

## :bulb: 데이터베이스 시스템 개요

### 1. 정보 시스템

 정보 시스템이란 데이터를 통해 정보를 얻어내는 시스템을 말합니다.
 
 * 데이터
 >현실 세계의 단순한 관찰을 통해 수집된 사실 또는 값
 
 * 정보
 >특정 해석이나 의미를 갖는 데이터
   
   ![info](https://user-images.githubusercontent.com/52366841/126595897-1debe566-f926-46fa-b00f-bf792189a98b.PNG)
   
 * collect
   데이터를 수집하는 행위
   
 * store
   데이터를 조직화(organize)하여 저장하는 행위
   
 * processing
   원하는 정보를 얻기 위해 데이터들을 처리
   
<br>


### 2. 데이터베이스 시스템과 DBMS

#### 1) 데이터베이스 시스템

 collect, processing, organize 등의 작업을 잘할 수 있도록 도와주는 시스템을 말합니다. 데이터베이스는 다음과 같은 특징이 있습니다.
 
 * 여러 사용자들의 공동 접근이 가능해야 한다.
 * 계속적인 변화를 통해 실시간으로 처리할 수 있는 운영 시스템이어야 한다.
 * 메모리 주소가 아닌 내용을 통해 데이터를 참조한다.
 ##### 실시간 접근성 / 계속적인 변화 / 동시 공유성 / 운영 가능 / 내용 참조
 
 <br>

#### 2) DBMS (Database Management System)

 어플리케이션과 시스템에 저장되어 있는 데이터의 중재자로서의 소프트웨어 시스템을 말합니다.
 흔히 알고있는 MySQL. Oracle, MS-SQL등이 DBMS입니다.

 ![db](https://user-images.githubusercontent.com/52366841/126597091-27149c18-2381-4665-bb30-9ab7b77a952c.PNG)
 
 * Meta data
 > 데이터를 위한 데이터로서, 데이터의 정보를 표현하는 데이터
 > ex) 회원의 비밀번호를 하나의 데이터라 할 때, "8~20글자의 영문자, 특수문자 포함"이라는 정보는 비밀번호를 위한 데이터입니다.
 > > 즉, "8~20글자의 영문자, 특수문자 포함"정보가 비밀번호의 Meta data입니다.
 
 <br>
 
### 3. DBMS의 기능

 DBMS는 데이터를 정의, 조작, 제어할 수 있어야 하며, 관계형 데이터베이스 관리 시스템(RDBMS)에서는 데이터를 SQL언어를 통해 다룰 수 있습니다.
 SQL은 다음과 같은 종류로 나눌 수 있습니다.
 
 * DDL (Data Definition Language)
 > 데이터를 정의하는 언어
 
 * DML (Data Manipulation Language)
 > 데이터를 조작하는 언어
 
 * TCL (Transaction Control Language)
 > 데이터의 안정성, 정확성을 유지하는 언어
 > Mutual exclution(상호배제)를 통한 transaction이 서로 방해를 받지 않도록 병행 제어

<br>

## :bulb: DB 설계 개요

### 1. DB설계 방법

 ![dbms](https://user-images.githubusercontent.com/52366841/126608468-40614532-c160-4d27-a9b2-bf8d8fa56078.PNG)
 
 DB 설계 단계는 위의 그림과 같습니다.
 
 1. 실세계 - 요구사항 수집 분석
 > 먼저 실제 세계에서 어떤 시스템을 구축할 것인지에 대한 요구사항을 수집합니다.
 > 요구사항에 대해 어떤 데이터들이 필요한지, 어떤 기능들이 필요한지 분석합니다.
 
 2. 개념적 설계
 > ER 다이어그램을 통해 요구사항을 개념적으로 표현합니다.
 
 3. 논리적 설계
 > 관계 모델(Relation model)을 통해 개념적 설계를 논리적으로 표현합니다.
 
 4. 물리적 설계
 > 실제 디스크와 같은 물리 저장장치에 데이터를 저장할 수 있도록 표현합니다.
 
 이 때, 개념적 설계와 논리적 설계에서 작성하는 ER 다이어그램과 Relation을 표현하는 것은 특정 DBMS에 관계가 없습니다.
즉, MySQL이든 Oracle이든 설계하는 방법이 같다는 의미입니다.
그런데 물리적 설계는 특정 DBMS를 전제로 한 모델링이기 때문에 DBMS에 의존적이어야 합니다.

### 2. DB설계 예시

 예를 들어, "대학교 학사 관리 시스템" DB를 구축한다고 가정해보겠습니다.
앞에서 살펴본 단계에 따라 학사 관리 시스템에는 어떤 정보들이 필요할 지 분석한 후, 개념적 설계 및 논리적 설계하는 방법은 간단하게 살펴보겠습니다.

#### 1) 현실 세계로부터 요구사항을 분석 및 수집

 요구사항을 분석해보니 학생과 교과목에 대한 정보만 있으면 되고, 학생과 교과목에는 다음과 같은 정보들이 있으면 될 것으로 파악되었습니다.
 
 * 학생은 학번, 이름, 학년의 정보를 갖습니다.
 * 과목은 학수번호, 과목명의 정보를 갖습니다.
 
 지금은 이렇게 간단하게 했지만, 요구사항을 파악하는 작업은 굉장히 중요합니다.
 설계를 마쳤는데, 빠진 부분이 있거나 추가해야할 부분이 있다면 설계를 처음부터 다시해야 할만큼 치명적이기 때문입니다.
 
#### 2) 개념적 설계

 개념적 설계는 ER 다이어그램 (Entity Relationship Diagram)을 통해 모델링하는 단계입니다.
 
 학생1, 학생2, 학생3을 각각 하나의 객체(Entity)라고 할 때, 각 객체들이 공통적으로 갖는 데이터 항목을 Entity type이라고 합니다.
 
 ![entity](https://user-images.githubusercontent.com/52366841/126612266-dd07b8d5-4d18-4cc6-9414-f137a9f4db1b.PNG)
 
 ER 다이어그램은 객체간의 관계 (Entity Relation)를 표현한 것으로서, 위에서 예로 든 "학사 관리 시스템"을 ER 다이어그램으로 표현하면 아래와 같습니다.
 
 ![takes](https://user-images.githubusercontent.com/52366841/126613107-0c9fbb58-39b8-4dbe-aa2b-86cfd52e254c.PNG)
 
 Takes는 학생이 강의를 수강한다는 관계를 표현한 것으로서, 이를 Relationship Type이라고 합니다.
 이렇게 객체간의 관계를 다이어그램으로 표현한 것을 ER 다이어그램이라 하며, 이 단계를 개념적 설계 단계라고 합니다.
 
#### 3) 논리적 설계

 논리적 설계는 개념적 설계에서 표현한 ER 다이어그램을 테이블로 표현하는 단계를 말합니다.
 여기서 말하는 테이블은 행과 열이 있는 표를 의미합니다. 
 SQL을 작성하기 위한 테이블 정의라고 보면 됩니다.
 
 "학사 관리 시스템"에서 ER 다이어그램을 바탕으로 논리적 설계를 해보면 다음과 같습니다.
 
 ![학사관리](https://user-images.githubusercontent.com/52366841/126613603-fd0ee988-ccbb-4fdd-9caf-15271b0f2b5a.PNG)
 
 각 Entity가 테이블로 대응됐고, Relationship Type도 테이블로 표현됐습니다.
 
#### 4) 물리적 설계

 이제 테이블의 구조, 즉 스키마가 정리됐으니 사용하는 DBMS의 SQL로 테이블을 생성해야 합니다.
 MySQL의 경우 Student 테이블을 다음과 같은 명령어로 생성할 수 있습니다.
 
 ```
 CREATE TABLE Student (
  student_no INT NOT NULL AUTO INCREMENT PRIMARY KEY,
  student VARCHAR(30) NOT NULL,
  year int NOT NULL
 );
 
 ```
 
 
## :bulb: ER 모델 개념적 설계

### 1. ER 모델 (Entity Relation Model)

 ER 모델은 요구사항으로부터 얻어낸 정보들을 개체(Entity), 애트리뷰트(Attribute), 관계성(Relation)으로 기술하는 데이터 모델을 말합니다.
 
 ![er](https://user-images.githubusercontent.com/52366841/126725614-10255902-c7f0-48d7-ab15-7a72edf3cb6b.PNG)
 
 * 개체 (Entity)
 > 개체란 단독으로 존재하는 객체를 의미하며, 동일한 객체는 존재하지 않습니다.
 > > 예를 들어, 학생 정보가 학번, 이름, 학년이 있을 때, 3개의 정보가 모두 같은 학생이 오직 한 명이면 이를 개체라고 합니다.
 > > 즉, 학생 한명이 개체가 되는 것입니다.
 
 * 애트리뷰트, 속성 (Attribute)
 > 개체가 갖는 속성을 의미합니다.
 > > 예를 들어, Student에서 학번, 이름, 학년 같은 정보를 속성이라 합니다.
 > ER 다이어그램에서 Attribute는 원으로 표현합니다.
 
 * 관계 (Relation)
 > Entity Type간의 관계를 의미합니다.
 > > 예를 들어, 수강을 뜻하는 Takes는 학생과 과목간의 "수강"이라는 관계를 갖습니다.
 > > 이 때, Takes를 Relation Type이라 하며, Relation Type 역시 속성을 가질 수 있습니다.
 > ER 다이어그램에서 Relation은 마름모로 표현합니다.
 
 ER 다이어그램을 구성하는 요소는 위와 같습니다.
 이제부터 ER 다이어그램을 그리기 위한 각 요소들을 표현하는 방법에 대해 알아보도록 하겠습니다.
 
### 2. 애트리뷰트 (Attribute)

#### 1) Attribute Domain

 * 해당 Attribute가 가질 수 있는 집합(도메인)을 말합니다.
 * 예를 들어,
 > 학생의 학년을 뜻하는 year 애트리뷰트는 1,2,3,4 와 같은 숫자만 허용하므로 year의 Arrtibute Domain은 정수형(integer)입니다.
 > 학생의 이름을 뜻하는 name 애트리뷰트는 문자열이어야 하므로 name의 Attribute Domain은 문자열(String)입니다.
 
#### 2) 키 애트리뷰트 (Key Attribute) 

 * 다른 객체들과 중복되지 않는 고유한 값을 가진 Attribute로서, 주로 객체를 식별하는데 사용되는 Attribute입니다.
 * 예를 들어, 학생의 학번을 의미하는 Student_no는 다른 학생들과 중복되지 않는 고유한 번호입니다.
 > 따라서 Student_no는 Key Attribute 입니다.
 * Key Attribute를 ER 다이어그램에서는 원에 밑줄로 표시합니다.
 
 ![key](https://user-images.githubusercontent.com/52366841/126726539-d102eb8c-d394-4f2e-9fdd-09a0f5c24880.PNG)
 
#### 3) 복합 애트리뷰트 (Composite Attribute) 
 
  * 독립적인 Attribute들이 모여서 생성된 Attribute를 의미합니다.
  * 예를 들어, 학생의 주소를 나타내는 Address 애트리뷰트가 있을 때, 우리나라에서 주소는 "경기도", "OO시", "OO동", "OO아파트"와 같이 표현합니다.
  > 즉, Address는 위의 4개의 독립된 Attribute가 모여서 생성된 Attribute이므로 Address를 Composite Attribute라고 합니다.
  
  ![compo](https://user-images.githubusercontent.com/52366841/126728116-c130ffcd-7cc1-41f2-919c-23f2dd9a8e76.PNG)

#### 4) 다중값 애트리뷰트 (Multi-Valued Attribute)

 * 하나의 Attribute가 여러 개의 값을 가지는 Attribute를 의미합니다.
 * 예를 들어, 학생의 전공을 나타내는 Degree Attribute가 있을 때, 이 학생이 복수 전공을 할 경우 Degree Attribute 값이 2개가 되므로, 이 때 Degree Attribute를 Multi-Valued Attribute라고 합니다.
 * 이와 달리, 오직 하나의 값을 갖는 애트리뷰트를 단일값 애드리뷰트 (Single-Valued Attribute)라고 합니다.
 * Multi-Valued Attribute는 ER 다이어그램에서 두 개의 원으로 표현합니다.
 
 ![multi](https://user-images.githubusercontent.com/52366841/126728371-cf1d6074-7512-4d6e-b711-9b740cb1a52d.PNG)
 
#### 5) 유도된 애트리뷰트 (Derived Attribute)

 * 다른 Attribute가 갖고 있는 값으로부터 계산되어져 나온 Attribute를 의미합니다.
 * 예를 들어, 모든 상품의 총 가격을 나타내는 total, 상품의 가격을 나타내는 price, 상품의 개수를 나타내는 count Attribute가 있다고 가정하겠습니다.
 > total은 price와 count의 곱으로 계산되어져 나오는 값이므로 total Attribute는 Derived Attribute입니다.
 * Derived Attribute는 ER 다이어그램에서 원을 점선으로 표현합니다.
 
 ![derived](https://user-images.githubusercontent.com/52366841/126728705-ff94c752-0ae8-4330-a4d7-7b0a805c047e.PNG)
 
### 3. 관계성 (Relationship)

 ER 다이어그램을 설계하는 가장 큰 목적은 Entity Type을 정의하고 Entity Type간의 관계를 표현하는 것입니다.
 Attribute를 통해 Entity Type을 정의했다면, Relationship을 통해 Entity Type간의 관계를 표현합니다.
 
 관계성은 2가지 제약조건을 명시함으로써 표현할 수 있습니다.
 
#### 1) 카디널리티 비율 제약조건 (Cardinality Ratio Constraint)

 관계를 맺는 두 Entity Type에 대해, 한 개체가 얼마나 많은 다른 개체와 관련될 수 있는지를 나타내는 제약조건을 뜻합니다.
 
 * 일대일 (1:1)
 > 두 개 Entity Type의 개체들은 서로 일대일로 대응
 
 * 일대다 (1:N)
 > 하나의 개체가 다른 Entity Type의 많은 개체들과 관련되지만, 그 역은 성립하지 않음

 * 다대다(N:M)
 > 하나의 개체가 다른 Entity Type의 많은 개체들과 관련되며, 역이 성립
 
 예를 들어, "학사 관리 시스템"에서 한 학생은 많은 과목을 수강할 수 있고 한 과목에는 많은 학생이 수강하므로, Student Entity Type과 Course Entity Type은 N:M 관계입니다.
 이러한 카디널리티 비율제약조건을 ER 모델에 표현하면 다음과 같이 N, M을 명시해줘서 표현합니다.
 
 ![TYPE](https://user-images.githubusercontent.com/52366841/126730715-ca4f8e47-12f6-4922-b800-bcaeb9026a22.PNG)
 
 또 다른 예시로, 부모와 자식 Entity Type 관계에서 부모는 많은 자식을 가질 수 있지만 자식은 한 부모만 가질 수 있습니다.
 즉, 부모와 자식은 1:M 관계이며, 이를 ER 다이어그램으로 다음과 같이 표현할 수 있습니다. 
 M에 해당하는 Entity Type에 M을 명시해주면 됩니다.
 
 ![1m](https://user-images.githubusercontent.com/52366841/126731249-89580dde-3df8-454b-86bf-b3d397bd8095.PNG)
    
#### 2) 참여 제약조건 (Participation Constraint)

 관계를 맺는 두 Entity Type에 대해 한 개체의 존재가 다른 개체의 존재에 의존하는지 여부를 나타내는 제약조건을 뜻합니다.
 
 * 전체 참여 (Total Participation)
 > 하나 또는 그 이상의 개체가 참여
 
 * 부분 참여 (Partial Participation)
 > 선택적인 참여
 
 예를 들어, 학생은 과목을 꼭 수강 할 필요가 없지만 과목은 항상 수강생이 있어야 합니다.
 수강생이 없는 과목은 폐강되기 때문입니다.
 
 ER 모델에서 전체 참여는 두 개의 실선으로 부분 참여는 한 개의 실선으로 표현하고, 이를 표현하면 다음과 같습니다.
 
 ![partici](https://user-images.githubusercontent.com/52366841/126731583-f72d540c-0a88-4d33-bfd5-a901632092a8.PNG)
 
#### 3) 구조적 제약조건 (Structural Constraint)

 앞서 살펴 본 두 개의 제약조건을 가리켜 구조적 제약조건이라 합니다.
 구조적 제약조건은 관계를 맺는 두 Entity Type에 1, N, M을 표시하거나 한 줄 또는 두 줄을 표시하지 말고 (MIN,MAX)방식으로 두 제약조건을 한 번에 표현하는 방식입니다.
 
 예를 들어, 학생은 최소 3개, 최대 6개의 강의를 수강할 수 잇으며, 강의는 최소 10명 최대 100명의 학생들이 들을 수 있을 때, 이를 ER 다이어그램으로 표현하면 다음과 같습니다.
 
 ![STRUCT](https://user-images.githubusercontent.com/52366841/126731844-f7158a71-f33a-447a-b9d7-87afe08760c5.PNG)
 
 지금까지 여러 애트리뷰트와 관계성의 두 가지 제약조건의 개념, 그리고 이를 ER 다이어그램에서 어떻게 표현하는지에 대해 알아보았습니다.
 이 내용들을 정리하면 아래 그림과 같습니다.
 
 ![SYMBOL](https://user-images.githubusercontent.com/52366841/126731928-92c5fade-e147-4226-837d-c54a68a83cd8.PNG)
 
#### 4) 약한 개체 (Weak Entity)와 식별 관계성 타입 (Identifying Relationship Type)

 약한 개체란 자신의 Key Attribute가 없는 Entity Type을 뜻합니다.
 
 예를 들어 "학사 관리 시스템"에서 강의번호 10043는 10043-01, 10043-02와 같이 여러 개의 분반이 있을 수 있습니다.
 이 때 분반이라는 개체는 자신의 Key Attribute가 없고, 강의 테이블에 의존하기 때문에 약한 개체라 합니다.
 다시 말하면 분반이 존재하기 위해서는 꼭 Course Entity Type이 있어야 합니다.
 
 강의와 분반의 관계를 ER 다이어그램으로 표현하면 다음과 같습니다.
 
 ![bunban](https://user-images.githubusercontent.com/52366841/126732196-23e492e5-764e-470a-8f26-5be9a4de3e8d.PNG)
 
 ER 다이어그램에서는 약한 개체는 두 개의 네모로 표현하고, 약한 개체의 key인 bun_no를 partial key (부분 키)라고 합니다.
 부분 키는 단독으로 존재할 수 없고 자신을 소유하고 잇는 Owner Entity Type인 Course Entity type의 key와 합쳐서 표현되어야 합니다.
 ER 다이어그램에서 부분 키는 점선으로 된 밑줄로 표현합니다.
 
 또한 Entity type이 약한 개체와 관계를 맺을 때는 식별 관계성 타입으로 표현하고, ER 다이어그램에서 두 개의 마름모로 표현합니다.
 약한 개체는 항상 의존적이기 때문에 참여 제약 조건은 전체 참여 (total participation)입니다.
 
## :bulb: 관계 모델 논리적 설계
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
    
    
    
    
    
    
    
