# Database 이론

* [관계형 DB에서의 관계](#관계형-DB에서의-관계)

* [Connection pool](#Connection-pool)

* [데이터베이스 시스템 개요](#데이터베이스-시스템-개요)

* [DB 설계 개요](#DB-설계-개요)
  
* [ER 모델 개념적 설계](#ER-모델-개념적-설계)
  
* [관계 모델 논리적 설계](#관계-모델-논리적-설계)

* [트랜잭션(transaction)과 ACID 특성을 보장하는 방법](#트랜잭션(transaction)과-ACID-특성을-보장하는-방법)

* [신뢰성과 회복(Recovery)](#신뢰성과-회복(Recovery))

* [뷰(View)](#뷰(View))

* [정규화 (Normalization)](#정규화 (Normalization))
 
* [인덱스(Index)](#인덱스(Index))
 
</br>

## :bulb: 관계형 DB에서의 관계

 관계형 데이터베이스( MySQL, Oracle, MS-SQL, SQLite 등 )는 엔티티(객체)끼리 관계를 맺을 수 있어서 관계형 DB라는 이름이 붙었습니다. 관계는 두 엔티티가 서로 관련이 있을 때를 말하는데, 다음과 같은 관계를 맺을 수 있습니다.
 * 일대일 (1:1)
 * 일대다 (1:N)
 * 다대다 (N:M)
 
### 1. 일대일 관계(1:1)

   1 : 1 관계란 어느 엔티티 쪽에서 상대 엔티티를 보더라도 반드시 단 하나씩 관계를 가지는 것을 말합니다.
  
   예를 들면, 우리나라에서 결혼제도는 일부일처제입니다.
  즉, 한 남자는 한 여자와, 한 여자는 한 남자와 밖에 결혼을 할 수 없습니다. 
  법적으로 남편을 또는 부인을 2명 이상 둘 수 없습니다.
  이러한 관계를 1:1 관계라고 합니다.
  
  <br>
  
### 2. 일대다 관계(1:N)
  
   1 : M 관계는 한 쪽 엔티티가 관계를 맺은 엔티티 쪽의 여러 객체를 가질 수 있는 것을 의미합니다.
  이 관계는 매우 흔한 방식이며, 실제 DB를 설계할 때 자주 쓰이는 방식입니다.
  
   예를 들면, 부모와 자식 관계라고 생각하시면 됩니다.
  부모는 자식을 1명만 낳을 수도 있고, 2명, 3명, 4명, 10명 그 이상도 낳을수 있습니다.
  DB에서는 이를 부모가 자식을 소유한다고 (has a 관계) 표현합니다.
  반대로 자식 입장에서는 부모(어머니, 아버지의 쌍)를 하나만 가질 수 밖에 없습니다.
  이러한 관계를 1 : N 관계라고 하며, 계층적인 구조로 이해할 수도 있습니다.
  
  <br>
  
### 3. 다대다 관계(N:M)

   N : M 관계는 관계를 가진 양쪽 엔티티 모두에서 1 : M 관계가 존재할 때 나타나는 모습입니다.
  즉, 서로가 서로를 1:N 관계로 보고 있는 것입니다.
  
   예를 들면, 쇼핑몰에서 회원과 상품이 관계를 맺을 수 있습니다.
  한 회원은 쇼핑몰의 여러 상품들을 가질 수 있습니다.
  청바지, 모자, 티셔츠, 남방 등 다 제가 가질 수 있죠.
  반대로 한 티셔츠도 여러 회원들을 가질 수 있습니다.
  하나의 티셔츠를 나도 친구도 부모님도 가질 수 있습니다.
  이처럼 관계를 맺은 두 엔티티가 서로 많이 가질 수 있을 때, 이를 N : M 관계라고 합니다.
  
  <br>
  
### 4. 대표키와 외래키

   table을 각 엔티티를 식별할 수 있는 대표 키(PK, Primary key)가 존재합니다.
  대표키는 중복되지 않는 값입니다. (unique)
  
   예를 들어, 주민 번호는 대한민국 국민들을 식별할 수 있는 대표 키가 됩니다.
  주민등록증이 같은 사람은 있을 수 없기 때문에, 대표 키로서 기능을 할 수 있습니다.
  
  <br>
  
  #### 테이블간의 관계를 맺을 때, 흔히 대표키를 이용하여 관계를 맺습니다.
   예를 들어, 1 : N 관계의 대표적인 예로 게시글과 댓글을 생각해보겠습니다.
  게시글은 여러 댓글들을 가지고 있으며, 댓글은 어떤 한 게시글에만 속해 있습니다.
  따라서 게시글과 댓글은 1:N 관계라 할 수 있습니다.
  
   게시글은 자신이 어떤 댓글들을 가지고 있는지 어떻게 알 수 있을까요?
  댓글 테이블을 설계할 때 컬럼에는 아래와 같은 정보들이 있을 수 있습니다.
  
  * 댓글 아이디(PK)
  * 작성자 명
  * 내용
  * 작성일
  
   여기서 어떤 게시글에 속해 있는지에 대한 정보가 필요하므로 하나의 컬럼이 더 필요한데, 이를 외래키( FK, Foreign key )라 합니다.
  
  * 게시글 아이디(FK)

   여기서 게시글 아이디는 게시글 테이블의 대표 키이며, 이를 댓글 테이블의 외래키로 지정하여 관계를 맺을 수 있습니다.
  
   즉, 게시글은 어떤 댓글들이 자신의 댓글들인지 알 필요 없고, 댓글만 자신이 어떤 게시글에 속하는지만 알면 1:N 관계를 성립할 수 있습니다.
  그 역할이 외래키인 것이죠.

   그렇다면 N:M 관계에서는 어떨까요?
  여기서는 서로가 서로를 1:M , 1:N  관계로 갖고 있기 때문에, 서로의 PK가 자신의 외래키 컬럼으로 갖고 있으면 됩니다.
  일반적으로 N:M 관계는 두 테이블의 대표키를 컬럼으로 갖는 또 다른 테이블을 생성해서 관리합니다.
  
  [ 참고자료 ] <http://www.dbguide.net/db.db?cmd=view&boardUid=12851&boardConfigUid=9&categoryUid=216&boardIdx=40&boardStep=1>

  
  <br>
  
## :bulb: Connection pool
  
### 1. 커넥션 풀(Connection pool)

  커넥션 풀이란 DB와 미리 connection( 연결 )을 해놓은 객체들을 pool( 웅덩이 )에 저장해두었다가, 클라이언트 요청이 오면 커넥션을 빌려주고, 볼일이 끝나면 다시 커넥션을 반납받아 pool에 저장하는 방식을 말합니다.
    
  ![connection](https://user-images.githubusercontent.com/52366841/126592139-6cb3b358-9bf1-426b-8016-0d45ef37fef9.PNG)
    
  클라이언트가 DB와 연결이 필요할 때, connection pool에서 connection을 빌려와 DB에 접근해서 쿼리를 날린 후, 볼 일이 끝나면 사용했던 connection을 다시 pool에 반납을 하는 과정을 표현했습니다.
  
<br>
    
### 2. 특징 / 장단점

 예를 들어, 게시판 웹 애플리케이션을 가정해보겠습니다. 어떤 유저가 게시글을 작성하는 과정을 보면, 그 과정은 다음과 같습니다.
 
 1. 클라이언트가 서버로 게시글 데이터를 전달
 2. 비즈니스 로직 처리
 3. DB와 커넥션을 맺은 후, DB에 게시글 데이터를 저장
 4. DB와 커넥션을 끊고, 비즈니스 로직 처리
 5. 클라이언트에 응답
 
 그런데 서비스가 커져서 유저가 한 명이 아니라, 100명의 유저가 동시에 접속 중이라고 가정해보겠습니다.
위와 같은 경우 매번 DB와 커넥션을 맺고 끊는 과정이 필요한데 커넥션 풀을 사용하게 되면, 미리 연결을 맺고 있는 커넥션들이 있기 때문에 커넥션을 맺고 끊는 과정이 불필요합니다.
즉, DB 접근 시 불필요한 작업(커넥션 생성, 끊기)이 사라지므로 성능향상을 기대할 수 있습니다.

 DB에서는 기본적으로 커넥션을 일정량 제공해줍니다.
그런데 유저가 많아져서 커넥션이 모자랄 경우, 즉 기본으로 제공된 커넥션이 모자랄 경우 원활한 서비스가 이루어지지 않습니다.
커넥션이 반납될 때까지 기다려야 하기 때문이죠. 따라서 유저수에 따라 커넥션을 조절할 필요가 있습니다.

 그렇다고 커넥션을 막 늘리는 것은 좋지 않습니다.
컴퓨터 세계에서는 항상 trade off가 있듯이, 커넥션 풀을 통한 장점도 있지만 단점도 있습니다.
커넥션 또한 객체이므로 메모리를 차지하게 됩니다.
따라서 무작정 많이 늘리는 것은 메모리를 많이 차지하게 되므로 오히려 성능이 떨어지는 결과를 가져옵니다.

<br>

## :bulb: 데이터베이스 시스템 개요

### 1. 정보 시스템

 정보 시스템이란 데이터를 통해 정보를 얻어내는 시스템을 말합니다.
 
 * 데이터
 >현실 세계의 단순한 관찰을 통해 수집된 사실 또는 값
 
 * 정보
 >특정 해석이나 의미를 갖는 데이터
   
   ![info](https://user-images.githubusercontent.com/52366841/126595897-1debe566-f926-46fa-b00f-bf792189a98b.PNG)
   
 * collect
   데이터를 수집하는 행위
   
 * store
   데이터를 조직화(organize)하여 저장하는 행위
   
 * processing
   원하는 정보를 얻기 위해 데이터들을 처리
   
<br>


### 2. 데이터베이스 시스템과 DBMS

#### 1) 데이터베이스 시스템

 collect, processing, organize 등의 작업을 잘할 수 있도록 도와주는 시스템을 말합니다. 데이터베이스는 다음과 같은 특징이 있습니다.
 
 * 여러 사용자들의 공동 접근이 가능해야 한다.
 * 계속적인 변화를 통해 실시간으로 처리할 수 있는 운영 시스템이어야 한다.
 * 메모리 주소가 아닌 내용을 통해 데이터를 참조한다.
 ##### 실시간 접근성 / 계속적인 변화 / 동시 공유성 / 운영 가능 / 내용 참조
 
 <br>

#### 2) DBMS (Database Management System)

 어플리케이션과 시스템에 저장되어 있는 데이터의 중재자로서의 소프트웨어 시스템을 말합니다.
 흔히 알고있는 MySQL. Oracle, MS-SQL등이 DBMS입니다.

 ![db](https://user-images.githubusercontent.com/52366841/126597091-27149c18-2381-4665-bb30-9ab7b77a952c.PNG)
 
 * Meta data
 > 데이터를 위한 데이터로서, 데이터의 정보를 표현하는 데이터
 > ex) 회원의 비밀번호를 하나의 데이터라 할 때, "8~20글자의 영문자, 특수문자 포함"이라는 정보는 비밀번호를 위한 데이터입니다.
 > > 즉, "8~20글자의 영문자, 특수문자 포함"정보가 비밀번호의 Meta data입니다.
 
 <br>
 
### 3. DBMS의 기능

 DBMS는 데이터를 정의, 조작, 제어할 수 있어야 하며, 관계형 데이터베이스 관리 시스템(RDBMS)에서는 데이터를 SQL언어를 통해 다룰 수 있습니다.
 SQL은 다음과 같은 종류로 나눌 수 있습니다.
 
 * DDL (Data Definition Language)
 > 데이터를 정의하는 언어
 
 * DML (Data Manipulation Language)
 > 데이터를 조작하는 언어
 
 * TCL (Transaction Control Language)
 > 데이터의 안정성, 정확성을 유지하는 언어
 > Mutual exclution(상호배제)를 통한 transaction이 서로 방해를 받지 않도록 병행 제어

<br>

## :bulb: DB 설계 개요

### 1. DB설계 방법

 ![dbms](https://user-images.githubusercontent.com/52366841/126608468-40614532-c160-4d27-a9b2-bf8d8fa56078.PNG)
 
 DB 설계 단계는 위의 그림과 같습니다.
 
 1. 실세계 - 요구사항 수집 분석
 > 먼저 실제 세계에서 어떤 시스템을 구축할 것인지에 대한 요구사항을 수집합니다.
 > 요구사항에 대해 어떤 데이터들이 필요한지, 어떤 기능들이 필요한지 분석합니다.
 
 2. 개념적 설계
 > ER 다이어그램을 통해 요구사항을 개념적으로 표현합니다.
 
 3. 논리적 설계
 > 관계 모델(Relation model)을 통해 개념적 설계를 논리적으로 표현합니다.
 
 4. 물리적 설계
 > 실제 디스크와 같은 물리 저장장치에 데이터를 저장할 수 있도록 표현합니다.
 
 이 때, 개념적 설계와 논리적 설계에서 작성하는 ER 다이어그램과 Relation을 표현하는 것은 특정 DBMS에 관계가 없습니다.
즉, MySQL이든 Oracle이든 설계하는 방법이 같다는 의미입니다.
그런데 물리적 설계는 특정 DBMS를 전제로 한 모델링이기 때문에 DBMS에 의존적이어야 합니다.

### 2. DB설계 예시

 예를 들어, "대학교 학사 관리 시스템" DB를 구축한다고 가정해보겠습니다.
앞에서 살펴본 단계에 따라 학사 관리 시스템에는 어떤 정보들이 필요할 지 분석한 후, 개념적 설계 및 논리적 설계하는 방법은 간단하게 살펴보겠습니다.

#### 1) 현실 세계로부터 요구사항을 분석 및 수집

 요구사항을 분석해보니 학생과 교과목에 대한 정보만 있으면 되고, 학생과 교과목에는 다음과 같은 정보들이 있으면 될 것으로 파악되었습니다.
 
 * 학생은 학번, 이름, 학년의 정보를 갖습니다.
 * 과목은 학수번호, 과목명의 정보를 갖습니다.
 
 지금은 이렇게 간단하게 했지만, 요구사항을 파악하는 작업은 굉장히 중요합니다.
 설계를 마쳤는데, 빠진 부분이 있거나 추가해야할 부분이 있다면 설계를 처음부터 다시해야 할만큼 치명적이기 때문입니다.
 
#### 2) 개념적 설계

 개념적 설계는 ER 다이어그램 (Entity Relationship Diagram)을 통해 모델링하는 단계입니다.
 
 학생1, 학생2, 학생3을 각각 하나의 객체(Entity)라고 할 때, 각 객체들이 공통적으로 갖는 데이터 항목을 Entity type이라고 합니다.
 
 ![entity](https://user-images.githubusercontent.com/52366841/126612266-dd07b8d5-4d18-4cc6-9414-f137a9f4db1b.PNG)
 
 ER 다이어그램은 객체간의 관계 (Entity Relation)를 표현한 것으로서, 위에서 예로 든 "학사 관리 시스템"을 ER 다이어그램으로 표현하면 아래와 같습니다.
 
 ![takes](https://user-images.githubusercontent.com/52366841/126613107-0c9fbb58-39b8-4dbe-aa2b-86cfd52e254c.PNG)
 
 Takes는 학생이 강의를 수강한다는 관계를 표현한 것으로서, 이를 Relationship Type이라고 합니다.
 이렇게 객체간의 관계를 다이어그램으로 표현한 것을 ER 다이어그램이라 하며, 이 단계를 개념적 설계 단계라고 합니다.
 
#### 3) 논리적 설계

 논리적 설계는 개념적 설계에서 표현한 ER 다이어그램을 테이블로 표현하는 단계를 말합니다.
 여기서 말하는 테이블은 행과 열이 있는 표를 의미합니다. 
 SQL을 작성하기 위한 테이블 정의라고 보면 됩니다.
 
 "학사 관리 시스템"에서 ER 다이어그램을 바탕으로 논리적 설계를 해보면 다음과 같습니다.
 
 ![학사관리](https://user-images.githubusercontent.com/52366841/126613603-fd0ee988-ccbb-4fdd-9caf-15271b0f2b5a.PNG)
 
 각 Entity가 테이블로 대응됐고, Relationship Type도 테이블로 표현됐습니다.
 
#### 4) 물리적 설계

 이제 테이블의 구조, 즉 스키마가 정리됐으니 사용하는 DBMS의 SQL로 테이블을 생성해야 합니다.
 MySQL의 경우 Student 테이블을 다음과 같은 명령어로 생성할 수 있습니다.
 
 ```
 CREATE TABLE Student (
  student_no INT NOT NULL AUTO INCREMENT PRIMARY KEY,
  student VARCHAR(30) NOT NULL,
  year int NOT NULL
 );
 
 ```
 
 
## :bulb: ER 모델 개념적 설계

### 1. ER 모델 (Entity Relation Model)

 ER 모델은 요구사항으로부터 얻어낸 정보들을 개체(Entity), 애트리뷰트(Attribute), 관계성(Relation)으로 기술하는 데이터 모델을 말합니다.
 
 ![er](https://user-images.githubusercontent.com/52366841/126725614-10255902-c7f0-48d7-ab15-7a72edf3cb6b.PNG)
 
 * 개체 (Entity)
 > 개체란 단독으로 존재하는 객체를 의미하며, 동일한 객체는 존재하지 않습니다.
 > > 예를 들어, 학생 정보가 학번, 이름, 학년이 있을 때, 3개의 정보가 모두 같은 학생이 오직 한 명이면 이를 개체라고 합니다.
 > > 즉, 학생 한명이 개체가 되는 것입니다.
 
 * 애트리뷰트, 속성 (Attribute)
 > 개체가 갖는 속성을 의미합니다.
 > > 예를 들어, Student에서 학번, 이름, 학년 같은 정보를 속성이라 합니다.
 > ER 다이어그램에서 Attribute는 원으로 표현합니다.
 
 * 관계 (Relation)
 > Entity Type간의 관계를 의미합니다.
 > > 예를 들어, 수강을 뜻하는 Takes는 학생과 과목간의 "수강"이라는 관계를 갖습니다.
 > > 이 때, Takes를 Relation Type이라 하며, Relation Type 역시 속성을 가질 수 있습니다.
 > ER 다이어그램에서 Relation은 마름모로 표현합니다.
 
 ER 다이어그램을 구성하는 요소는 위와 같습니다.
 이제부터 ER 다이어그램을 그리기 위한 각 요소들을 표현하는 방법에 대해 알아보도록 하겠습니다.
 
### 2. 애트리뷰트 (Attribute)

#### 1) Attribute Domain

 * 해당 Attribute가 가질 수 있는 집합(도메인)을 말합니다.
 * 예를 들어,
 > 학생의 학년을 뜻하는 year 애트리뷰트는 1,2,3,4 와 같은 숫자만 허용하므로 year의 Arrtibute Domain은 정수형(integer)입니다.
 > 학생의 이름을 뜻하는 name 애트리뷰트는 문자열이어야 하므로 name의 Attribute Domain은 문자열(String)입니다.
 
#### 2) 키 애트리뷰트 (Key Attribute) 

 * 다른 객체들과 중복되지 않는 고유한 값을 가진 Attribute로서, 주로 객체를 식별하는데 사용되는 Attribute입니다.
 * 예를 들어, 학생의 학번을 의미하는 Student_no는 다른 학생들과 중복되지 않는 고유한 번호입니다.
 > 따라서 Student_no는 Key Attribute 입니다.
 * Key Attribute를 ER 다이어그램에서는 원에 밑줄로 표시합니다.
 
 ![key](https://user-images.githubusercontent.com/52366841/126726539-d102eb8c-d394-4f2e-9fdd-09a0f5c24880.PNG)
 
#### 3) 복합 애트리뷰트 (Composite Attribute) 
 
  * 독립적인 Attribute들이 모여서 생성된 Attribute를 의미합니다.
  * 예를 들어, 학생의 주소를 나타내는 Address 애트리뷰트가 있을 때, 우리나라에서 주소는 "경기도", "OO시", "OO동", "OO아파트"와 같이 표현합니다.
  > 즉, Address는 위의 4개의 독립된 Attribute가 모여서 생성된 Attribute이므로 Address를 Composite Attribute라고 합니다.
  
  ![compo](https://user-images.githubusercontent.com/52366841/126728116-c130ffcd-7cc1-41f2-919c-23f2dd9a8e76.PNG)

#### 4) 다중값 애트리뷰트 (Multi-Valued Attribute)

 * 하나의 Attribute가 여러 개의 값을 가지는 Attribute를 의미합니다.
 * 예를 들어, 학생의 전공을 나타내는 Degree Attribute가 있을 때, 이 학생이 복수 전공을 할 경우 Degree Attribute 값이 2개가 되므로, 이 때 Degree Attribute를 Multi-Valued Attribute라고 합니다.
 * 이와 달리, 오직 하나의 값을 갖는 애트리뷰트를 단일값 애드리뷰트 (Single-Valued Attribute)라고 합니다.
 * Multi-Valued Attribute는 ER 다이어그램에서 두 개의 원으로 표현합니다.
 
 ![multi](https://user-images.githubusercontent.com/52366841/126728371-cf1d6074-7512-4d6e-b711-9b740cb1a52d.PNG)
 
#### 5) 유도된 애트리뷰트 (Derived Attribute)

 * 다른 Attribute가 갖고 있는 값으로부터 계산되어져 나온 Attribute를 의미합니다.
 * 예를 들어, 모든 상품의 총 가격을 나타내는 total, 상품의 가격을 나타내는 price, 상품의 개수를 나타내는 count Attribute가 있다고 가정하겠습니다.
 > total은 price와 count의 곱으로 계산되어져 나오는 값이므로 total Attribute는 Derived Attribute입니다.
 * Derived Attribute는 ER 다이어그램에서 원을 점선으로 표현합니다.
 
 ![derived](https://user-images.githubusercontent.com/52366841/126728705-ff94c752-0ae8-4330-a4d7-7b0a805c047e.PNG)
 
### 3. 관계성 (Relationship)

 ER 다이어그램을 설계하는 가장 큰 목적은 Entity Type을 정의하고 Entity Type간의 관계를 표현하는 것입니다.
 Attribute를 통해 Entity Type을 정의했다면, Relationship을 통해 Entity Type간의 관계를 표현합니다.
 
 관계성은 2가지 제약조건을 명시함으로써 표현할 수 있습니다.
 
#### 1) 카디널리티 비율 제약조건 (Cardinality Ratio Constraint)

 관계를 맺는 두 Entity Type에 대해, 한 개체가 얼마나 많은 다른 개체와 관련될 수 있는지를 나타내는 제약조건을 뜻합니다.
 
 * 일대일 (1:1)
 > 두 개 Entity Type의 개체들은 서로 일대일로 대응
 
 * 일대다 (1:N)
 > 하나의 개체가 다른 Entity Type의 많은 개체들과 관련되지만, 그 역은 성립하지 않음

 * 다대다(N:M)
 > 하나의 개체가 다른 Entity Type의 많은 개체들과 관련되며, 역이 성립
 
 예를 들어, "학사 관리 시스템"에서 한 학생은 많은 과목을 수강할 수 있고 한 과목에는 많은 학생이 수강하므로, Student Entity Type과 Course Entity Type은 N:M 관계입니다.
 이러한 카디널리티 비율제약조건을 ER 모델에 표현하면 다음과 같이 N, M을 명시해줘서 표현합니다.
 
 ![TYPE](https://user-images.githubusercontent.com/52366841/126730715-ca4f8e47-12f6-4922-b800-bcaeb9026a22.PNG)
 
 또 다른 예시로, 부모와 자식 Entity Type 관계에서 부모는 많은 자식을 가질 수 있지만 자식은 한 부모만 가질 수 있습니다.
 즉, 부모와 자식은 1:M 관계이며, 이를 ER 다이어그램으로 다음과 같이 표현할 수 있습니다. 
 M에 해당하는 Entity Type에 M을 명시해주면 됩니다.
 
 ![1m](https://user-images.githubusercontent.com/52366841/126731249-89580dde-3df8-454b-86bf-b3d397bd8095.PNG)
    
#### 2) 참여 제약조건 (Participation Constraint)

 관계를 맺는 두 Entity Type에 대해 한 개체의 존재가 다른 개체의 존재에 의존하는지 여부를 나타내는 제약조건을 뜻합니다.
 
 * 전체 참여 (Total Participation)
 > 하나 또는 그 이상의 개체가 참여
 
 * 부분 참여 (Partial Participation)
 > 선택적인 참여
 
 예를 들어, 학생은 과목을 꼭 수강 할 필요가 없지만 과목은 항상 수강생이 있어야 합니다.
 수강생이 없는 과목은 폐강되기 때문입니다.
 
 ER 모델에서 전체 참여는 두 개의 실선으로 부분 참여는 한 개의 실선으로 표현하고, 이를 표현하면 다음과 같습니다.
 
 ![partici](https://user-images.githubusercontent.com/52366841/126731583-f72d540c-0a88-4d33-bfd5-a901632092a8.PNG)
 
#### 3) 구조적 제약조건 (Structural Constraint)

 앞서 살펴 본 두 개의 제약조건을 가리켜 구조적 제약조건이라 합니다.
 구조적 제약조건은 관계를 맺는 두 Entity Type에 1, N, M을 표시하거나 한 줄 또는 두 줄을 표시하지 말고 (MIN,MAX)방식으로 두 제약조건을 한 번에 표현하는 방식입니다.
 
 예를 들어, 학생은 최소 3개, 최대 6개의 강의를 수강할 수 잇으며, 강의는 최소 10명 최대 100명의 학생들이 들을 수 있을 때, 이를 ER 다이어그램으로 표현하면 다음과 같습니다.
 
 ![STRUCT](https://user-images.githubusercontent.com/52366841/126731844-f7158a71-f33a-447a-b9d7-87afe08760c5.PNG)
 
 지금까지 여러 애트리뷰트와 관계성의 두 가지 제약조건의 개념, 그리고 이를 ER 다이어그램에서 어떻게 표현하는지에 대해 알아보았습니다.
 이 내용들을 정리하면 아래 그림과 같습니다.
 
 ![SYMBOL](https://user-images.githubusercontent.com/52366841/126731928-92c5fade-e147-4226-837d-c54a68a83cd8.PNG)
 
#### 4) 약한 개체 (Weak Entity)와 식별 관계성 타입 (Identifying Relationship Type)

 약한 개체란 자신의 Key Attribute가 없는 Entity Type을 뜻합니다.
 
 예를 들어 "학사 관리 시스템"에서 강의번호 10043는 10043-01, 10043-02와 같이 여러 개의 분반이 있을 수 있습니다.
 이 때 분반이라는 개체는 자신의 Key Attribute가 없고, 강의 테이블에 의존하기 때문에 약한 개체라 합니다.
 다시 말하면 분반이 존재하기 위해서는 꼭 Course Entity Type이 있어야 합니다.
 
 강의와 분반의 관계를 ER 다이어그램으로 표현하면 다음과 같습니다.
 
 ![bunban](https://user-images.githubusercontent.com/52366841/126732196-23e492e5-764e-470a-8f26-5be9a4de3e8d.PNG)
 
 ER 다이어그램에서는 약한 개체는 두 개의 네모로 표현하고, 약한 개체의 key인 bun_no를 partial key (부분 키)라고 합니다.
 부분 키는 단독으로 존재할 수 없고 자신을 소유하고 잇는 Owner Entity Type인 Course Entity type의 key와 합쳐서 표현되어야 합니다.
 ER 다이어그램에서 부분 키는 점선으로 된 밑줄로 표현합니다.
 
 또한 Entity type이 약한 개체와 관계를 맺을 때는 식별 관계성 타입으로 표현하고, ER 다이어그램에서 두 개의 마름모로 표현합니다.
 약한 개체는 항상 의존적이기 때문에 참여 제약 조건은 전체 참여 (total participation)입니다.
 
 <br>
 
## :bulb: 관계 모델 논리적 설계

### 1. 관계 모델 (Relation Model)

 관계형 모델은 실제 세계의 데이터를 관계라는 개념을 사용해 표현한 데이터 모델입니다.
 데이터 모델이란 "~라는 개념을 사용해 데이터를 표현해주세요" 라고 정의하는 것을 말하며, 관계형 모델은 그중에 하나라고 할 수 있습니다.
 Mongo DB 같은 KVS (Key-Value Store)도 데이터 모델의 하나라고 볼 수 있습니다.
 
 관계형 모델은 수학의 집합론에 근거한 모델이며, 릴레이션(테이블)의 연산을 술어논리로 표현할 수 있어야 합니다.
 SQL과 관계형 모델을 동일시 여기는 경우가 있는데, 이 둘은 다른 개념입니다.
 그렇기 때문에 관계형 모델과 SQL에서 사용하는 용어도 다릅니다.
 
 관계 모델은 관계형 데이터베이스에 직접 구현할 수 있도록 DB구조를 정의하는 방법을 제공합니다.
 쉽게 테이블을 설계하는 과정이라고 생각하면 되고, ER 다이어그램을 기반으로 작업하는 것이 순서입니다.
 
 관계 모델은 릴레이션의 관계를 표현하는 것입니다.
 아래는 관계 모델의 핵심인 릴레이션에 대한 예시입니다.
 
 ![relation](https://user-images.githubusercontent.com/52366841/126738454-198e9d1d-75e2-4074-b03f-3534d6369b2d.PNG)
 
 * 릴레이션 (Relation)
 > 개체를 표현하기 위한 데이터 구조로써 2차원 테이블로 표현하며, heading(스키마)와 body(본체)로 구성되어 있습니다.
 > > heading은 속성(attribute)이 n개가 모인 집합이며, 이름과 데이터형으로 구성되어 있습니다.
 > > body는 속성값의 집합인 튜플(tuple)의 집합입니다.
 > SQL의 테이블과 대응됩니다.
 
 * 튜플 (Tuples)
 > 하나의 개체를 의미하고 Relation에서 행으로 표현하며, 이를 릴레이션 상태(Relation State)라고도 합니다.
 > 각 튜플은 유일해야 한다는 특징이 있습니다.
 > SQL의 row와 대응됩니다.
 
 * 애트리뷰트 (Attribute)
 > 개체의 속성들을 의미하며 Relation에서 열로 표현
 > SQL의 column과 대응됩니다.
 
 이를 정리하면, 릴레이션은 튜플의 모임이고, 릴레이션의 관계를 정의한 것이 관계 모델입니다.
 관계 모델은 릴레이션 단위로 다양한 연산을 사용해 질의를 수행하는 데이터 모델입니다.
 

### 2. 제약 조건

 관계 모델이 정의되기 위해서는 몇 가지의 제약 조건이 있습니다.
 
 
#### 1) 무결성 제약 조건 (Integrity constraints)

한 객체에 저장되는 데이터를 제한하는 조건을 말합니다.

* 도메인 제약 조건
> 각 튜플의 애트리뷰트는 도메인에 속하는 값이어야 합니다.
> 즉, 도메인이 Integer면 Integer 값만 저장될 수 있습니다.

* 엔티티 무결성 제약 조건
> 기본 키 값은 NULL이 될 수 없습니다.

* 참조 무결성 제약 조건
> 어떤 릴레이션 A의 튜플이 다른 릴레이션 B의 튜플을 참조하려면, 참조하려는 그 튜플은 B 릴레이션 내에 존재해야 합니다.
> 외래 키 (Foreign Key)는 참조 무결성 제약조건을 만족해야 합니다.
> > 외래 키 : 다른 릴레이션의 key 애트리뷰트를 참조하는 애트리뷰트


#### 2) 키 제약 조건

 서로 다른 튜플은 동일한 키 애트리뷰트를 갖지 않아야 한다는 조건을 말합니다.

### 3. ER 모델을 관계 모델로 변환

 관계 모델은 ER 모델을 기반으로 설계됩니다.
 개념적 설계인 ER 모델을 논리적 설계인 관계 모델로 바꾸는 방법은 다음과 같습니다.

#### 1) 일반적인 변환

 ![변환1](https://user-images.githubusercontent.com/52366841/126741048-827115e7-e8d2-46d2-af57-3c71607a225d.PNG)
 
 일반적으로 ER 모델과 Relation은 다음과 같이 대응됩니다.
 
 * 하나의 Entity는 한 개의 Relation으로 대응
 * Entity가 가지고 있는 Attribute들은 Relation의 Attribute로 대응
 * Relation Entity인 Takes 역시 하나의 Relation으로 표현

 이것이 ER 모델을 Relation으로 변환하는 일반적인 방법입니다.
 
 지금부터 ER 모델의 특별한 Attribute에 대해서 ER 모델을 Relation모델로 변환할 때의 주의점, 또 두 Entity간의 관계성에 따라 릴레이션의 수를 줄일 수 있는 방법에 대해 알아보도록 하겠습니다.
  
#### 2) 복합 Attribute

 복합 Attribute을 구성하고 있는 독립된 Attribute들을 나눠서 관계 모델의 Attribute로 작성합니다.
 
 ![복합](https://user-images.githubusercontent.com/52366841/126741942-b593a60c-9a08-4922-b3c5-f6d9475ed89c.PNG)
 
 ER 모델의 복합 Attribute인 Address를 구성하고 있는 do, si, dong, apartment Attribute들은 관계 모델로 변환할 때 일반적인 단일 Attribute처럼 취급합니다.
 
#### 3) 약한 개체 (Weak Entity)

 ER 모델에서 약한 개체는 독립적으로 존재할 수 없고 Owner Entity Type에 종속적입니다.
 그런데 관계 모델로 변환할 때는 약한 개체를 독립된 Relation으로서 작성해야 합니다.
 
 ![weak](https://user-images.githubusercontent.com/52366841/126742183-eb0adac9-9f0d-4aef-938c-31589a3c989a.PNG)
 
 bunban Entity는 약한 개체로서 Course에 종속적입니다.
 약한 개체인 bunban을 ER 모델에서 Relation으로 변환할 때는 하나의 Relation으로 표현합니다.
 이 때 주의할 것은 bunban Relation의 Attribute에 Owner Entity Type인 Course Entity의 key가 Attribute로 추가된다는 것입니다.
 즉, bunban Relation의 속성에는 course_no가 추가됩니다.
 
#### 4) 유도된 Attribute

 ER 모델의 유도된 Attribute는 Relation 모델에서는 생략됩니다.
 
 ![유도](https://user-images.githubusercontent.com/52366841/126742508-ea1b97c5-4e95-4fa6-8f35-4477929a9724.PNG)
 
 상품 가격의 총합을 나타내는 total Attribute는 price와 count에 의해 계산되어진 유도된 Attribute입니다.
 유도된 Attribute는 ER 모델에서 Relation으로 변환할 때 Attribute로 추가되지 않습니다.
 그래서 변환된 Relation에는 total이라는 Attribute가 없습니다.
 
#### 5) 다중값 Attribute

 다중값 Attribute의 각 Attribute 값들은 Relation에서 하나의 튜플이 됩니다.
 
 ![다중값](https://user-images.githubusercontent.com/52366841/126743337-af62e87e-a013-4694-9f7f-d1b2d5a48f44.PNG)
 
 Student Entity에 friends라는 다중값 Attribute가 있을 때,
 왼쪽 릴레이션처럼 다중값 Attribute를 하나의 튜플안에 표현하는 것이 아니라,
 오른쪽 릴레이션처럼 friends의 각 값들이 각각 하나의 튜플이 되어 작성되어야 합니다.
 
 참고로 이렇게 중복을 없애는 작업을 정규화라고 합니다.
 
 앞서 일반적인 변환에서 ER 모델의 Relation Type을 관계 모델로 변환을 할 때 별도의 릴레이션을 작성해야 한다고 했었습니다.
 그 이유는 두 Entity가 관계를 맺고 있다는 것을 두 Entity의 primary key를 Attribute로 하는 하나의 릴레이션으로 만듦으로써 표현할 수 있기 때문입니다.
 그러나 릴레이션이 많아지는 것은 연산이 복잡해진다는 것을 의미하기 때문에 릴레이션의 수를 줄이는 것이 좋습니다.
 
 Relationship으로는 1:1, 1:N, M:N이 있으며 어떤 경우에는 ER 모델의 Relation Type이 관계 모델로 변환될 때 생략될 수 있습니다.
 물론 다른 방법으로 두 Entity의 관계를 표현합니다.
 이제 Relationship의 각 경우에 대해 ER 모델을 관계 모델로 변환할 때의 주의사항을 알아보겠습니다.
 
#### 6) 1:1 관계

 어떤 두 Entity의 관계성이 1:1 관계일 때 ER 모델의 Relation Type을 관계 모델로 변환을 할 경우, Relation Type에 해당하는 릴레이션을 따로 만들지 않고, 한 쪽의 Entity에 다른 Entity의 primary key와 Relation Type의 Attribute들을 Attribute로 추가합니다.
 
 예를 들어, Employee Entity Type에 e_no가 101~105인 개체 5개가 있고, Store Entity Type에 s_no가 101~103인 개체 3개가 있다고 해보겠습니다.
 
 두 Entity를 어느 한 쪽으로 합쳤을 때의 결과를 보면 다음과 같습니다.
 
 ![onetoone](https://user-images.githubusercontent.com/52366841/126918776-a61dee5d-f134-4620-8476-2f740c696a18.PNG)
 
 Employee 릴레이션에 manage의 startDate 애트리뷰트, Store의 primary key인 s_no를 추가할 경우 왼쪽 릴레이션과 같고,
 Store 릴레이션에 manage의 startDate 애트리뷰트, Employee의 primary key인 e_no를 추가할 경우 오른쪽 릴레이션과 같습니다.
 두 방식의 차이점은 null이 있느냐 없느냐 입니다.
 Employee의 경우 Store와 관계를 맺지 않고 있는 튜플이 많이 있기 때문에, Employee에 합칠 경우 관계를 맺지 않는 개체에 대해서 null값이 생성됩니다.
 반면 Store쪽으로 합칠 경우에는 null이 생성되지 않습니다.
 
 null이 적게 생기는 릴레이션 쪽으로 Attribute를 추가하는 것이 좋습니다.
 즉, 1:1 관계일 때 ER 모델을 관계 모델로 변환하는 방법은 
 
 * Relation Type에 해당하는 릴레이션을 생성하지 않는다.
 * 원래 Relation Type에 있어야 할 Attribute들을 관계를 맺는 두 릴레이션 중 한쪽으로 합친다.
 > 합칠 때 null이 적게 생기는 경우를 선택하여 합친다.
 
#### 7) 1:M 관계

 1:M 관계에서도 마찬가지로 Relation Type에 해당하는 릴레이션을 생성하지 않고 릴레이션을 합칩니다.
 
 ![onetomany](https://user-images.githubusercontent.com/52366841/126919241-a43a7bfe-ea97-44c1-b686-95c9f8b6455c.PNG)
 
 부모(parent)는 많은 자식(Children)을 가질 수 있고 자식은 한 부모를 가지므로, 부모와 자식은 1:M 관계입니다.
 이 경우 ER 모델을 관계 모델로 변환할 때, Many에 해당하는 릴레이션 쪽으로 Attribute들을 합칩니다.
 즉, parent, relate의 Attribute들이 모두 children으로 합쳐집니다.
 이렇게 합치는 이유 역시, null이 적게 생기기 때문입니다.
 
#### 8) N:M 관계

 N:M 관계는 앞에서 소개했던 일반적인 경우처럼, 관계를 맺는 두 Entity의 primary key를 가져와서 하나의 릴레이션을 생성합니다.
 즉, 기존의 두 엔티티가 릴레이션으로 변환되고, primary key를 가져와 하나의 릴레이션을 생성하여 총 3개의 릴레이션이 생깁니다.
 
 <br>
 
## :bulb: 트랜잭션(transaction)과 ACID 특성을 보장하는 방법

### 1. 트랜잭션 (transaction)

 트랜잭션이란 질의(Query)를 하나의 묶음 처리해서 만약 중간에 실행이 중단됐을 경우, 처음부터 다시 실행하는 Rollback을 수행하고, 오류없이 실행을 마치면 commit을 하는 실행 단위를 의미합니다.
 즉, 한 번 질의가 실행되면 질의가 모두 수행되거나 모두 수행되지 않는 작업수행의 논리적 단위입니다.
 
 예를 들어, 친구에게 인터넷 뱅킹으로 10,000원을 송금하는 상황을 가정해보겠습니다.
 제가 친구에게 송금을 한다면, 저의 계좌에서 10,000원을 차감하고 친구의 계좌에 10,000을 증가시켜야 하는데,
 알 수 없는 오류로 인해 저의 계좌에서는 10,000원이 줄었지만 친구 계좌에는 10,000원이 증가되지 않는다면 어떻게 될까요?
 저의 10,000원은 그냥 공중으로 증발해버리는 문제가 발생합니다.
 이러한 경우가 생기지 않도록 중간에 오류가 발생하면 다시 처음부터 송금을 하도록 하는 것이 rollback입니다.
 오류 없이 정상적으로 송금이 됐다면 정상적으로 실행이 끝났으므로 commit을 합니다.
 즉, 송금 과정을 하나의 트랜잭션이라 볼 수 있습니다.
 
 참고로 트랜잭션을 작업수행의 논리적 단위라고 했는데요, 때문에 DBMS의 성능은 초당 트랜잭션의 실행 수(TPS: Transaction per second)로 측정합니다.
 
#### 트랜잭션 사용 이유

 트랜잭션은 DB 서버에 여러 개의 클라이언트가 동시에 액세스 하거나 응용프로그램이 갱신을 처리하는 과정에서 중단될 수 있는 경우 등 데이터 부정합을 방지하고자 할 때 사용합니다.
 부정합이 발생하지 않으려면 프로세스를 병렬로 처리하지 않도록 하여 한 번에 하나의 프로세스만 처리하도록 하면 되는데, 이는 효율이 너무 떨어집니다.
 즉, 병렬로 처리할 수 밖에 없는 현실적인 상황으로 인해 부정합을 방지하고자 트랜잭션을 사용하는 것입니다.
 트랜잭션에서 중요한 것은 스케줄 관리입니다.
 

### 2. 특성

 트랜잭션에는 아래와 같이 4가지의 특성이 있습니다.
 4가지 특성의 앞 글자만 따서 ACID 특성이라 합니다.
 
 * 원자성 (Atomicity)
 > 트랜잭션의 작업이 부분적으로 실행되거나 중단되지 않는 것을 보장하는 것을 말합니다.
 > 즉, All or Nothing의 개념으로써 작업 단위를 일부분만 실행하지 않는다는 것을 의미합니다.
 
 * 일관성 (Consistency)
 > 트랜잭션이 성공적으로 완료되면 일관적인 DB 상태를 유지하는 것을 말합니다.
 > 여기서 말하는 일관성이란, 위의 송금 예제에서 금액의 데이터 타입이 정수형(Integer)인데, 갑자기 문자열(String)이 되지 않는 것을 말합니다.
 > > 즉, 송금 전후 모두 금액의 데이터 타입은 정수형이어야 한다는 것이 일관성입니다.
 
 * 격리성 (Isolation)
 > 트랜잭션 수행시 다른 트랜잭션의 작업이 끼어들지 못하도록 보장하는 것을 말합니다.
 > 즉, 트랜잭션끼리는 서로를 간섭할 수 없습니다.
 
 * 지속성 (Durability)
 > 성공적으로 수행된 트랜잭션은 영원히 반영이 되는 것을 말합니다.
 > commit을 하면 현재 상태는 영원히 보장됩니다.
 
### 3. 원자성 보장

 트랜잭션에서 원자성은 수행하고 있는 트랜잭션에 의해 변경된 내역을 유지하면서, 이전에 commit된 상태를 임시 영역에 따로 저장함으로써 보장합니다.
 즉, 현재 수행하고 있는 트랜잭션에서 오류가 발생하면 현재 내역을 날려버리고 임시 영역에 저장했던 상태로 rollback 합니다.
 
 이전 데이터들이 임시로 저장되는 영역을 롤백 세그먼트 (rollback segment)라고 하며, 현재 수행하고 있는 트랜잭션에 의해 새롭게 변경되는 내역을 데이터베이스 테이블이라고 합니다.
 다시 말하면, 트랜잭션의 원자성은 롤백 세그먼트에 의해 보장된다고 할 수 있습니다.
 
 그런데 오류가 발생하면 rollback을 하는데, 트랜잭션의 길이가 길어지면 어떻게 될까요?
 확실하게 오류가 발생하지 않는 부분도 다시 처음부터 작업을 수행해야 합니다.
 따라서 확실한 부분에 대해서는  rollback이 되지 않도록 중간 저장 지점인 save point를 지정할 수 있습니다.
 save point를 지정하면 rollback 할 때 save point 이전은 확실하다 간주하고 그 이후부터 진행하게 됩니다.
 
 ![11](https://user-images.githubusercontent.com/52366841/127081290-13695503-68db-463d-afa6-4e354189f053.PNG)
 
### 4. 일관성 보장

 트랜잭션에서 일관성은 트랜잭션 수행 전, 후에 데이터 모델의 모든 제약 조건 (기본키, 외래키, 도메인, 도메인 제약조건 등)을 만족하는 것을 통해 보장합니다.
 
 예를 들어, Movie와 Video 테이블이 있을 때 Video 테이블에 Movie 테이블의 primary key인 movie_id가 외래키로 존재한다고 가정하겠습니다.
 만약 movie_id의 제약조건이 Movie 테이블에서 변경되면, Video 테이블에서도 movie_id가 변경되어야 합니다.
 한 쪽의 테이블에만 데이터 변경사항이 이루어지면 안됩니다.
 
 그렇다면 어떻게 트랜잭션은 일관성을 보장할까요?
 어떤 이벤트와 조건이 발생했을 때, 트리거(Trigger)를 통해 보장합니다.
 트리거는 "방아쇠"인데, 데이터베이스 시스템이 자동적으로 수행할 동작을 명시하는데 사용됩니다.
 어떤 행위의 시작을 알리는 것이죠.
 
 ![trigger](https://user-images.githubusercontent.com/52366841/127279363-87de9512-fa04-4979-b182-35ea1e1aa088.PNG)
 
 위의 코드는 트리거가 호출되면, 수행할 질의들을 트리거로 생성해서 작성한 코드입니다.
 create는 트리거를 생성하는 코드이고, after는 트리거가 실행되기 위한 event를 나타냅니다.
 
### 5. 고립성 보장

 트랜잭션이 고립성을 보장하는 방법에 대해 이해하기 위해서는 병행 트랜잭션에 대해 먼저 알아야 합니다.
 
#### 1) 병행 처리 (concurrent processing)

 CPU가 여러 프로세스를 처리하는 것처럼, 트랜잭션에 정해진 시간을 할당해서 작업을 하다가 부여된 시간이 끝나면 다른 트랜잭션을 실행하는 이런 방식으로 트랜잭션들을 조금씩 처리하는 것을 말합니다.
 그런데 이렇게 되면 많은 트랜잭션들이 조금씩 처리되는 과정에서 공통된 데이터를 조작하게 되는데, 이 경우 데이터가 혼란스러워 질 수 있습니다.
 
 예를 들어, A 트랜잭션에서는 x 라는 데이터를 100으로 설정한 후 시간이 만료되어 B 트랜잭션으로 넘어갔다고 가정해보겠습니다.
 B 트랜잭션에서는 x 데이터에 -50 연산을 해서 저장을 했을 때, 시간이 만료되어 다시 A 트랜잭션이 실행될 경우 x 데이터의 값은 50이 됩니다.
 이렇게 트랜잭션이 조금씩 수행될 때, 공통된 데이터가 다른 트랜잭션에 의해 방해되면 안됩니다.
 이와 같이 트랜잭션의 간섭이 일어날 경우 갱신분실, 오손판독, 반복불가능, 팬텀문제 등 여거 문제점들이 발생합니다.
 
#### 2) 고립성 보장

 병행처리 과정에서 트랜잭션의 고립성이 왜 보장되어야 하는지 알게되었습니다.
 
 그러면 고립성을 어떻게 보장할 수 있을까요?
 OS의 세마포어(semaphore)와 비슷한 개념으로 lock & execute unlock을 통해 고립성을 보장할 수 있습니다.
 즉, 데이터를 읽거나 쓸 때는 문을 잠궈서 다른 트랜잭션이 접근하지 못하도록 고립성을 보장하고, 수행을 마치면 unlock을 통해 데이터를 다른 트랜잭션이 접근할 수 있도록 허용하는 방식입니다.
 트랜잭션에서는 데이터를 읽을 때, 여러 트랜잭션이 읽을 수 있도록 허용하는 shared_lock을 합니다.
 즉, shared_lock은 데이터 쓰기를 허용하지 않고 오직 읽기만 허용합니다.
 
 또한 데이터를 쓸 때는 다른 트랜잭션이 읽을 수도 쓸 수도 없도록 하는 exclusive_lock을 사용합니다.
 그리고 읽기, 쓰기 작업이 끝나면 unlock을 통해 다른 트랜잭션이 lock을 할 수 있도록 데이터에 대한 잠금(lock)을 풀어줍니다.
 
 그런데 lock과 unlock을 잘못 사용하면 데드락(deadlock) 상태에 빠질 수 있습니다.
 모든 트랜잭션이 아무것도 수행할 수 없는 상태가 되는 것이죠.
 
 ![deadlock](https://user-images.githubusercontent.com/52366841/127282197-376438a8-cf6d-4a38-9d0b-2a948aa8f296.PNG)
 
#### 3) 2PL 프로토콜 (2 Phase Locking protocol)

 당연히 데드락이 걸리면 안되므로, 어떤 규칙에 의해서 고립성을 보장해야 한다는 2PL 프로토콜이 연구되었습니다.
 2PL 프로토콜이란 여러 트랜잭션이 공유하고 있는 데이터에 동시에 접근할 수 없도록 하기위한 목적을 가진 프로토콜입니다.
 
 이름 그대로 2가지 단계의 locking이 존재하는데, 한 가지는 growing phase이고 다른 한 가지는 shrinking phase입니다.
 상승 단계란 read_lock, write_lock을 의미하고, 하강 단계란 unlock을 의미합니다.
 
 2PL 프로토콜은 상승 단계와 하강 단계와 섞이면 안된다는 것을 의미합니다.
 즉, lock과 unlock이 번갈아 수행되지 않고 lock이 쭉 수행된 후에 unlock이 쭉 수행되어야 한다는 것이 이 프로토콜입니다.
 
 ![2PL](https://user-images.githubusercontent.com/52366841/127283637-34210e37-ab04-489e-847a-99c58be5dcc3.PNG)
 
 정리하면 성능을 위해 병행처리를 해야하는데, 트랜잭션의 고립성을 보장하기 위해서는 2PL을 사용해야 한다는 것입니다. (Serializable Schedule)
 
 참고로 locking을 하는 방법에도 두 가지가 있습니다.
 
 * 보수적 locking (conservative locking)
 > 트랜잭션이 시작되면 모든 lock을 얻는 방식으로써, 데드락이 발생하지 않지만 병행성이 좋지 못함
 
 * 엄격한 locking (strict locking)
 > 트랜잭션이 commit을 만날 때까지 lock을 갖고 있다가 commit을 만날때 unlock을 하는 방식으로 데드락이 발생하지만 병행성이 좋음
 > > 일반적으로 병행성이 좋은 strict 방식을 사용합니다.
 
 <br>
 
## :bulb: 신뢰성과 회복(Recovery)

### 1. 회복

 트랜잭션이 수행되는 동안 시스템에 알 수 없는 오류 또는 물리적으로 문제가 발생했을 때, 트랜잭션의 수행을 되돌려야 합니다.
 rollback이란 트랜잭션 내의 질의를 수행하면서 문제가 발생했을 경우에 수행되는 것이지만,
 시스템의 오류 또는 물리적인 문제의 경우는 시스템 상의 문제이므로 트랜잭션이 다시 수행되어야 합니다.
 이를 시스템 회복(recovery)이라 합니다.
 회복은 데이터의 신뢰성을 보장하며, 트랜잭션의 원자성과 영속성을 보장합니다.
 
### 2. undo, redo와 check point

 시스템 오류 또는 물리적인 문제를 실패(failure)라고 합니다.
 failure에는 두 종류가 있습니다.
 
 * local failure
 > 하나의 트랜잭션 실패를 의미
 
 * global failure
 > 모든 트랜잭션이 실패하는 것을 의미
 
 실패가 발생하면 시스템의 회복을 위해 undo 또는 redo를 수행합니다.
 
 * undo
 > 트랜잭션을 이전 상태로 되돌리는 것을 의미
 
 * redo
 > 이전 상태로 되돌아간 후, 실패가 발생하기 전까지의 과정을 그대로 따라가는 것을 의미합니다.
 > redo를 하기 위해서는 정상적으로 실행 되기까지의 과정을 기록해야 하는데, 이를 log라고 합니다.
 
 또, check point라는 개념도 있습니다.
 
 * check point
 > check point로 설정한 지점 이전까지는 트랜잭션이 성공적으로 수행이 돼서 disk에 확실히 저장된 상태를 의미합니다.
 > check point를 설정하는 이유는 시스템을 회복하기 위해 되돌아갈 때, 너무 많이 되돌아가지 않도록 하기 위함입니다.
 > > 만약 실패가 발생하여 회복을 할 때 check point가 설정되어 있다면, redo는 check point 시점부터 log를 따라가면서 트랜잭션을 수행하지만, undo는 log를 따라가지 않고 트랜잭션을 재수행 합니다.
 
 이제 여러 트랜잭션이 병행 처리 되는 과정에서 실패가 발생할 경우, undo와 redo가 어떻게 수행되는지 알아보도록 하겠습니다.
 
 ![redo](https://user-images.githubusercontent.com/52366841/127418623-05c1965f-56e4-473d-97f4-1bd5dbadd214.PNG)
 
 위의 그림에서,
 
 * 트랜잭션 T1
 > check point 이전에 실행이 완료되었으므로 failure 되더라도 이미 disk에 저장이 된 상태이므로 회복을 하지 않습니다.
 
 * 트랜잭션 T2
 > check point 이전에 실행된 내용은 disk에 반영이 되었으므로 check point 이후의 내용을 log를 따라 redo를 수행합니다.
 
 * 트랜잭션 T3
 > failure 시점에 실행중이었으므로 check point 시점으로 undo한 후, 트랜잭션을 재실행합니다.
 
 * 트랜잭션 T4
 > check point 이후에 실행됐고 failure 시점 전에 실행이 끝났으므로 redo를 수행합니다.
 
 * 트랜잭션 T5
 > check point 이후에 실행됐고 failure 시점에 실행중이었으므로 시작 지점까지 undo한 후, 트랜잭션을 재실행합니다.
 
### 3. redo와 undo를 어떻게 구분할 수 있을까?

 그런데 DBMS는 어떻게 해서 트랜잭션이 redo 할 것과 undo 할 것을 구분할 수 있을까요?
 
 ![DBMS](https://user-images.githubusercontent.com/52366841/127419433-e12427ba-40d2-4630-98e9-8011576c1385.PNG)
 
 회복을 위해 시스템이 restart되면, DB에서 restart file을 읽습니다.
 restart file은 log의 check point record를 참조하고 있으며, check point record에서 undo할 대상을 확인합니다.
 
 위의 예제를 통해 어떻게 undo와 redo 목록을 정하는지 그 과정을 살펴보겠습니다.
 
 1. 먼저, check point 시점에서 commit된 트랜잭션은 T2와 T3입니다. 따라서 T2와 T3는 undo할 트랜잭션이 됩니다.
 2. 이어서 T4가 시작되므로 T4도 undo list에 추가됩니다.
 3. 그러다가 undo list에 있던 T2가 종료되므로, T2를 undo list에서 제거하고 redo list에 추가합니다.
 4. 다음으로 T5가 시작되므로 T5를 undo list에 추가합니다.
 5. 마지막으로 T4는 종료되므로 redo list에 추가됩니다.
 
 이러한 과정을 통해 failure 시점에서 undo list와 redo list에 작성된 트랜잭션에 대해 undo와 redo를 수행합니다.
 
 <br>
 
## :bulb: 뷰(View)

### 1. 보안성

 DBMS가 지원하는 보안에는 다음과 같은 것들이 있습니다.
 
 * 사용자 확인을 통한 계정 보안
 * DB 객체 보호를 위한 접근 보안
 * DB와 File 보호를 위한 OS 보안
 
 이번에는 DB 객체 보호를 위한 보안으로써 뷰(View)에 대해 알아보려고 합니다.

### 2. 뷰(View)
 
 DB 객체를 보호하는 방법으로 사용자에게 권한(privilage)을 부여하는 방법이 있습니다.
  
 이와 달리, 뷰 테이블 (원본 테이블을 그대로 두고, 노출하고 싶은 필요한 정보들만 모아서 만든 가상 테이블)을 만들어 보호하는 방법이 있습니다.
 즉, 사용자가 보는 테이블은 실제 테이블이 아닌 가상의 테이블이므로, 원본 테이블에 영향을 주지 않기 때문에 DB 객체를 보호할 수 있습니다.
  
 ![image](https://user-images.githubusercontent.com/52366841/127432779-a3238bd5-58ae-4f9a-8dcc-a33af2a50646.png)
  
 위의 쿼리는 VIEW_SAMPLE 이라는 이름의 뷰를 생성하는 쿼리입니다.
 원본 테이블(base table)은 Student이고, VIEW_SAMPLE은 stu_no와 name만을 Attribute로 갖는 가상의 테이블이죠.
 이와 같이 보여주고 싶은 Attribute만 선택해서 뷰를 만들 수 있습니다.
  
 뷰는 가상의 테이블이지만, 일반적인 테이블 처럼 쿼리를 수행할 수 있습니다.
 단, SELECT 쿼리에 대해서는 제약조건이 없지만 UPDATE, DELETE, INSERT에 대해서는 제약조건이 있습니다.
 여기서 말하는 제약조건이란, 뷰의 Attribute에는 base table의 primary key가 존재해야 한다는 것입니다.
  
 그런데 사실 뷰의 목적은 데이터 조회에 있습니다.
 따라서 뷰의 데이터를 조회할 때 일반 테이블처럼 쿼리를 작성해도 됩니다.
 
### 3. 뷰를 사용하는 이유

 뷰를 사용하는 이유 역시, 독립성을 보장함에 있습니다.
 즉, 외부 스키마와 개념 스키마 간의 독립성 (3-level architecture의 logical interface) 을 보장하기 위함입니다.
 뷰가 독립성을 보장하는 개념은 다음과 같습니다.
 
 * growth
 > 뷰에 새로운 Attribute가 추가 되어도 base table에는 영향을 주지 않습니다.
 > 반대로 base table에 새로운 Attribute가 추가되어도 뷰에는 영향을 주지 않습니다.
 > 따라서 base table과 사용자가 실제로 보는 뷰 간의 데이터 독립성을 보장합니다.
 
 * restructuring
 > 뷰를 통해 base table 중 자주 쓰이는 필드만 골라 작은 테이블로 만들 수 있습니다.
 > 즉, 매번 base table에 접근할 필요 없이 뷰에 접근함으로써 연산을 줄일 수 있으며, 필요한 데이터만 보여줌으로써 보안성을 높일 수 있습니다.
 
 <br>
 
## :bulb: 정규화 (Normalization)

### 1. 정규화 (Normalization)

 관계형 모델에서는 정규화 이론이라는 DB 설계 이론이 있습니다.
 정규화 이론은 RDB를 효율적으로 잘 다루는데 있어 필요한 과정이며, 관계형 모델을 전제로 구축된 DB 설계 이론입니다.
 
 정규화의 가장 큰 이점은 모순을 방지할 수 있다는 것입니다.
 모순이란 논리적으로 불일치한 데이터가 발생하는 상황을 말하며, 모순이 발생한 상태를 변칙(Anomalies)이라고 합니다.
 
 예를 들어, 다음과 같은 릴레이션을 가정해보겠습니다.
 
 ![relation](https://user-images.githubusercontent.com/52366841/127972967-d8f3c277-e1ef-4a71-b331-71a61c254f7e.PNG)
 
 victolee는 1학년일까요 3학년일까요?
 릴레이션은 참인 명제의 집합이므로, 두 데이터 모두 사실입니다.
 즉, victolee가 1학년인지 3학년인지 명확히 알 수가 없는데, 이러한 상황을 변칙이 발생했다고 합니다.
 
 모순이 생기는 이유는 데이터의 중복이 가장 큰 역할을 하는데, 정규화를 통해 중복을 제거함으로써 모순을 해결할 수 있습니다.
 즉, 정규화는 릴레이션 내에서 중복을 제거하는 과정이라고 할 수 있습니다.
 
 정규화 과정, 즉 중복 제거를 통해 얻을 수 있는 이점은 다음과 같습니다.
 
 * 응용프로그램 단에서 불필요한 로직을 없앨 수 있다.
 * 올바른 데이터만 얻을 수 있다. (변칙 방지)
 * 불필요한 쿼리 (예를 들면, 서브쿼리) 제거로 성능 향상
 
### 2. 정규형 (Normal Form, NF)

 정규화 과정은 각각의 정규형이 되기 위한 조건들을 충족시키는 과정이라고 볼 수 있습니다.
 정규형에는 단계가 있는데, 높은 단계로 갈수록 중복이 적은 릴레이션으로 설계됩니다.
 
 * 제1 정규형(1NF)
 * 제2 정규형(2NF)
 * 제3 정규형(3NF)
 * 보이스코드 정규형(BCNF)
 * 제4 정규형(4NF)
 * 제5 정규형(5NF)
 * 제6 정규형(6NF)
 
 다음은 정규형의 대략적인 개요, 특징들을 말씀드리려 합니다.
 
 * 높은 단계의 정규형은 그 이전 정규형들이 갖는 조건들을 만족해야 합니다.
 > 예를 들어, 4NF는 1NF ~ BCNF까지의 정규형 조건들을 기본적으로 만족해야 합니다.
 
 * 핵심 정규형은 BCNF, 5NF이며, 그 외의 정규형을 목표로 하지 않습니다.
 > 일반적으로 BCNF를 만족하면 5NF를 만족하는 경우가 많기 때문에 BCNF를 목표로 두기도 합니다.
 
 * 특히 6NF는 직교성을 다룰 때 유용하지만, 릴레이션이 너무 많아져 불필요한 join이 많아지므로 6NF를 목표로 두진 않습니다.
 * 2NF ~ BCNF는 함수 종속성의 제거를 통해 만족하게 되며, 4NF ~ 6NF는 결합 종속성의 제거를 통해 이루어집니다.
 
### 3. 용어 정리

 각 정규형이 어떤 조건들을 만족해야 하고, 이를 해결하는 과정을 살펴보기 전에 용어를 먼저 정리하면 좋을 것 같습니다.
 
 1. 슈퍼키
 
   * 릴레이션에서 특정 튜플을 유일하게 구분할 수 있는 애트리뷰트의 조합을 가진 키
   * 튜플을 유일하게 구분할 수 있으면 되기 때문에, 슈퍼키는 여러개 존재할 수 있다.
   * 예를 들어 A,B,C 애트리뷰트가 있을 때 (A,B) (B,C) 조합만으로 튜플을 구분 할 수 있다면 해당 조합이 슈퍼키가 됩니다.
   
 2. 후보키
 
   * 슈퍼키 중에서 최소한의 애트리뷰트 조합으로 특정 튜플을 유일하게 구분 할 수 있는 키
   * 예를 들어 (A,B) (B,C) 슈퍼키가 존재할 때 B 애트리뷰트 만으로도 튜플을 구분할 수 있다면 B는 후보키 입니다.
   * 즉, 슈퍼키보다 작은 범위라고 할 수 있습니다.
   
 3. 진부분집합
 
   * 관계형 모델은 수학의 집합론에 근거한 모델이기 때문에 집합에 대한 개념이 필요합니다.
   * 진부분집합은 자신을 제외한 부분집합을 의미합니다.
   * 예를 들어 {1,2} 집합의 부분집합은 {공집합, {1}, {2}, {1,2}}이며 진부분집합은 {공집합, {1}, {2}}가 됩니다.
   
 4. 무손실 분해 (Lossless Decomposition)
 
   * 정규화를 진행하는 과정에서 중복을 제거하는 방법으로 릴레이션을 분해합니다. 이 때 원래의 정보를 잃어버리지 않으면서 분해하는 것을 무손실 분해라고 합니다.
   * 즉, 릴레이션을 분해할 때 무손실 분해가 되어야 합니다.
   * 무손실 분해가 되면 분해된 릴레이션을 join해서 원래의 정보를 얻을 수 있습니다.
 
 5. 함수 종속성 (Function Dependency)
 
   * 함수 종속성이란, 어떤 릴레이션 R의 애트리뷰트 A, B가 있다고 가정할 때 A의 값을 알면 B의 값을 알 수 있는 관계를 말합니다.
   * 이 때 A의 값은 유일해야 하며 B는 중복돼도 상관 없습니다.
   * 즉, 키의 값을 알면 다른 임의의 애트리뷰트 값을 구할 수 있는 것처럼, 키의 성질을 정의한 것이라 할 수 있습니다.
   
 6. 결합 종속성 (Join Dependency)
 
   * 결합 종속성이란, 어떤 릴레이션이 여러 개의 릴레이션으로 무손실 분해될 수 있다면, 여러 개의 릴레이션의 결합으로 원래 릴레이션을 만들 수 있는 관계를 말합니다.
   * 예를 들어 A,B,....,K를 릴레이션 R의 스키마의 부분집합이라고 할 때 A,B,....,K 릴레이션을 결합한 결과와 R이 같은 경우 결합 종속성을 만족 시킨다고 말합니다.
 
 7. 직교성 (Orthogonality)
 
   * 직교성은 여러 개의 릴레이션 사이의 중복제거에 대한 개념입니다.
   * 정규화는 한 개의 릴레이션 내부에서 중복을 없애는데 초점을 맞춘 작업인 반면, 직교성은 DB 전체에서 중복을 제거하는 작업입니다.
   
### 4. 제1 정규형, 1NF

 1NF를 만족하기 위한 조건은 "릴레이션이어야 한다." 이다.
 테이블과 릴레이션은 비슷하지만 다른 개념인데, 다음의 과정을 통해 테이블은 릴레이션과 같아진다.
 
 * 테이블에는 컬럼이나 행에 순서가 존재하지만, 릴레이션에는 순서가 존재하지 않기 때문에 순서를 고려하지 않습니다.
 * 중복되는 튜플이 존재하지 않는다.
 * 구체적인 값을 가져야 한다. 즉 값으로 NULL을 갖지 않습니다.
 * 값은 의미가 있는 한 묶음의 데이터, 즉 원자 단위이어야 합니다. (원자성)
 > > 원자 단위이려면, 각 행마다 한 컬럼에 하나의 값을 가져야 합니다.
 > > 예를 들어, 주소라는 컬럼에 "시, 도, 군, 상세주소"를 몽땅 저장하는 것은 바람직하지 않습니다.
 
 ![1NF](https://user-images.githubusercontent.com/52366841/127981015-cdda6b60-e305-49e5-9b0c-7b1fa677e8b4.PNG)
 
### 5. 제2 정규형, 2NF

 2NF는 후보키의 진부분집합에서 키가 아닌 속성에 대해, 부분 함수 종속성을 제거하는 작업입니다.
 즉, 릴레이션이 1NF 조건을 만족하고 부분 함수 종속성을 갖지 않으면, 그 릴레이션은 2NF가 됩니다.
 
 ![2NF](https://user-images.githubusercontent.com/52366841/127990368-01da355d-5fa8-482e-b480-7fb0258090a5.PNG)
 
 위의 예제에서 정규화를 하기 전 테이블을 보면, 이름과 학과는 후보키입니다.
 후보키 중 하나인(진부분집합) 이름을 알면 학년을 알 수 있으므로 함수 종속이 존재하고 있습니다.
 2NF는 이러한 함수 종속을 제거하는 작업입니다.
 
 함수 종속을 제거하려면 원래의 릴레이션을 무손실 분해시켜야 합니다.
 
 * 종속 관계가 있는 속성만 추출(Projection)해서 새로운 릴레이션을 만듭니다.
 * 즉, 이름과 학년을 애트리뷰트로 갖는 새로운 릴레이션이 생성됩니다.
 * 기존에 있던 원래 릴레이션은 떨어져나간 애트리뷰트(학년)를 제외한 릴레이션으로 존재합니다.
 
 함수 종속을 제거함으로써 이렇게 두 개의 릴레이션으로 쪼개지고, 두 릴레이션을 결합하면 원래의 릴레이션이 되므로 무손실 분해가 이루어졌습니다.

 ![2NF](https://user-images.githubusercontent.com/52366841/127991388-61c8df3f-00a0-444e-9169-0909848b6158.PNG)
 
### 6. 제3 정규형, 3NF

 3NF는 추이 함수 종속성(Transitive Dependency)을 제거하는 작업입니다.
 
 추이 함수 종속성은 키가 아닌 애트리뷰트 사이의 함수 종속성을 의미합니다.
 예를 들어, 키가 아닌 애트리뷰트 X, Y가 있고 X를 알면 Y값을 알 수 있는 함수 종속성이 있다고 가정해보겠습니다.
 3NF는 X와 Y 사이의 함수 종속성을 제거 하는 과정입니다.
 2NF는 후보키와 키가 아닌 애트리뷰트 사이의 함수 종속성을 제거했다는 점에서 차이가 있습니다.
 
 ![3NF](https://user-images.githubusercontent.com/52366841/127992018-a6f95cf0-cf9a-4caa-b23b-6806d67a865d.PNG)
 
 참고로 슈퍼키를 알면 X를 알 수 있고, X를 알면 Y를 알 수 있으므로 추이 함수 종속성이라는 말이 붙었습니다.
 
 ![3NF_](https://user-images.githubusercontent.com/52366841/127992136-0f79fac5-0488-4e3c-b870-2c5b5b523f7b.PNG)
 
 위의 예제는 후보키인 학번을 알면 우편번호를 알 수 있고, 우편번호를 알면 나머지 주소를 알 수 있기 때문에 추이 함수 종속관계입니다.
 따라서 우편번호 애트리뷰트를 기준으로 릴레이션을 분해합니다.
 릴레이션을 분해하는 방법은 2NF와 동일합니다.
 
### 7. 보이스코드 정규형, BCNF

 BCNF는 키가 아닌 애트리뷰트에서 후보키의 진부분집합에 대한 함수 종속성을 제거하는 작업입니다.
 
 ![BCNF](https://user-images.githubusercontent.com/52366841/128104874-cf00ca0e-16da-4563-9748-b37c1cfa11c0.PNG)
 
 위의 예제는 수강신청 릴레이션입니다.
 어떤 학생이 어떤 교수의 교과목을 선택했는지에 대한 애트리뷰트가 있으며, 학번과 교과목이 후보키입니다.
 
 기존의 릴레이션은 3NF를 만족합니다.
 어떤 학생이 어떤 교과목을 선택했는지의 조합에 따라 교수가 정해지기 때문에 2NF를 만족합니다.
 또한 키가 아닌 애트리뷰트인 교수번호를 통해 교수 이름을 알 수 있으므로 릴레이션을 분할하여 3NF를 만족합니다.
 
 그런데 교수는 특정 과목만 가르치기 때문에 교수번호를 알면 교과목을 알 수 있는 상황입니다.
 이는 2NF, 3NF에서 볼 수 없었던 함수 종속입니다.
 따라서 교과목은 후보키로 되어있고 교수번호는 후보키가 아니므로, 교수번호를 후보키로 지정하고 교과목은 후보키에서 제외합니다.
 
 정리하면 다음과 같습니다.
 
 * 기존에 (학번, 교과목)을 후보키로 하여 3NF를 만족하는 수강신청 릴레이션 존재
 * 키 애트리뷰트가 아닌 교수 번호를 통해 후보키인 교과목을 알 수 있음
 > > BCNF는 이러한 경우의 함수 종속을 제거합니다.
 * 교수 번호를 후보키로 지정, 교과목은 후보키에서 제외
 
 BCNF는 함수 종속성이 모두 제거된 상태의 정규형입니다.
 앞서 2NF와 3NF 그리고 BCNF를 거쳐 모든 경우의 수에 대해 함수 종속성을 제거했기 때문입니다.
 이로써 BCNF 이상에서 함수 종속성에 의한 무손실 분해를 할 수 없습니다.
 
### 8. 4NF, 5NF, 6NF

 BCNF까지의 정규화를 진행했다면, 자동으로 5NF의 조건을 만족하는 경우가 많습니다.
 그렇기 때문에 일반적으로 BCNF까지만 해도 충분합니다.
 이에 따라 BCNF 이후의 정규형은 개략적으로만 살펴보도록 하겠습니다.
 
 ##### 1) 4NF 이후 정규화는 어떤 상황에서 진행하는가?
 
 우선 BCNF 이후 정규화가 필요한지 아닌지는 "키가 아닌 애트리뷰트가 존재하는지 여부"입니다.
 예를 들어 {A, B, C, X}의 애트리뷰트로 구성된 릴레이션이 있을 때 {A, B, C}를 후보키라 가정하겠습니다.
 X값을 알고 싶다면 후보키 (A, B, C)가 필요하며 이는 함수 종속입니다.
 BCNF이면 함수 종속을 해결한 상태이므로 4NF 이상의 정규형을 진행할 필요가 없게됩니다.
 
 ##### 2) 4NF / 5NF / 6NF
 
 흔히 4NF는 다치 종속성 (MultiValued Dependency, MVD) 을 제거하고 한다고 하지만 폭 넓게 결합 종속성을 제거하는 과정입니다.
 A 애트리뷰트를 알면 X라는 다중값 (B, C 애트리뷰트) 을 알 수 있을 때, 이러한 종속성을 제거하는 것입니다.
 
 5NF 역시 결합 종속성을 제거하는 과정입니다.
 릴레이션에 애트리뷰트 A, B, C가 있을 때 {A,B} {B,C} {A,C} 애트리뷰트 조합을 갖는 릴레이션으로 분해될 수 있을 때, 이러한 결합 종속성을 제거하는 것입니다.
 
 6NF는 모든 관계가 후보키와 하나 이상의 다른 (키 또는 비 키) 속성으로 구성됨을 의미합니다.
 6NF는 직교성에 있어 유용한 정규형이지만, 6NF를 하게 되면 릴레이션이 너무 많아지므로 join을 많이 하게 된다는 단점이 있습니다.
 
 <br>
 
## :bulb: 인덱스(Index)

### 1. 인덱스

 인덱스는 키 값으로 행 데이터의 위치를 식별하는데 사용하는 기능입니다.
 그러기 위해서는 원본 테이블을 기준으로 잘 정렬된 별도의 테이블, 즉 인덱스 테이블을 생성해야 하고 이로 인해 데이터 엑세스 성능을 높일 수 있습니다.
 인덱스의 존재 유무에 따라 쿼리의 결과는 달라지지 않습니다.
 
 인덱스를 효과적으로 사용하려면 정규화가 되어 있어야 합니다.
 정규화가 되어 있지 않은 테이블은 컬럼이 많으며, 이에 따라 조합할 수 있는 인덱스가 많아지게 됩니다.
 인덱스가 많으면, 갱신 성능이 나빠지고 디스크 공간도 많아지므로 인덱스를 효과적으로 사용하려면 정규화가 잘 되어 있어야 합니다.
 
 ##### 인덱스 특징
 인덱스는 다음과 같은 특징이 있습니다.
 
 * 인덱스 테이블
 > 이진트리 검색을 위해서는 미리 데이터가 정렬되어 있어야 합니다.
 > 하지만 데이터가 항상 정렬되어 있기란 어렵기 때문에 특정 컬럼을 기준으로 이진트리를 생성하는 새로운 테이블을 생성하여 미리 정렬된 상태를 만들어야 합니다.
 > MySQL에서는 테이블을 생성할 때 특정 컬럼을 PK로 설정하면 그 컬럼에 대한 인덱스 테이블을 자동으로 만듭니다.
 
 ![index](https://user-images.githubusercontent.com/52366841/128116035-b14b1118-43e2-47ba-8f7a-7602e9a24163.PNG)
 
 * 인덱스 테이블은 일반 테이블과 같이 데이터베이스 객체입니다.
 * 인덱스 테이블만으로는 아무런 기능을 할 수 없기 때문에 다른 테이블에 의존적입니다.
 
 검색 성능이 좋다고 항상 좋은 것은 아닙니다. 언제나 trade off가 존재합니다.
 인덱스를 사용하면 다음과 같은 단점이 있습니다.
 
 * 자원
 > 인덱스 테이블이라는 테이블이 생성되므로 메모리를 많이 소비하게 됩니다.
 > 따라서 PK 같은 컬럼들을 인덱싱 하도록 하고, 많은 컬럼을 인덱스로 사용하지 않도록 남용하지 않는 것이 좋습니다.
 
 * SELECT를 제외한 INSERT, UPDATE, DELETE에 대한 성능 저하
 > 어떤 테이블에 데이터를 추가할 경우, 이에 관계된 인덱스 테이블에서는 데이터를 정렬해야 하므로 전체적인 성능이 저하됩니다.
 
### 2. 인덱스 종류, B+ 트리를 중심으로

 인덱스에는 여러 종류가 있습니다.
 일반적으로 B+트리 인덱스를 사용하는데 어떤 인덱스를 사용하는지는 벤더 제품에 따라 다릅니다.
 
 다음은 인덱스의 종류에 대한 간단한 소개입니다.
 
 * 해시 인덱스 (Hash Index)
 > 해시 테이블을 이용한 인덱스로, 해시값을 사용합니다.
 > 해시 값을 사용하기 때문에 매우 빠르지만, 등가비교검색 (값이 같은지 다른지)만 가능합니다.
 > 기본키는 등가비교만 해도 충분한 경우가 많으므로 해시 인덱스를 고려해볼 수 있습니다.
 
 * 풀 텍스트 인덱스 (Full Text Index)
 > "oo"단어를 포함한 행을 검색하고 싶을 때 사용합니다.
 > B+트리는 LIKE 검색으로 중간일치, 후방일치 검색을 할 수 없지만 전문 검색 인덱스 방법으로는 가능합니다.
 > 형태 분석법, N그램을 통해 단어를 구분합니다.
 
 * R 트리 인덱스 (공간 인덱스)
 > 최소 경계 사각형 (MBR Minimun Bounding Rectangle)이라는 개념을 사용해 인덱스를 구성합니다.
 > > MBR이란 어떤 도형을 둘러싼 최소의 직사각형을 의미합니다.
 > 2차원의 데이터를 인덱싱하고 검색하려는 목적으로 사용되며 GPS(위도, 경도) 같은 공간 검색에 활용됩니다.
 
 * 그 밖에
 > 함수 인덱스
 > 비트맵 인덱스
 
 ##### B+트리
 
 RDB에서 인덱스는 일반적으로 B+트리 자료구조를 이용하여 검색을 수행하며,
 B+트리는 다음과 같이 구성됩니다.
 
 ![B+Tree](https://user-images.githubusercontent.com/52366841/128123524-5e39dabd-e956-409c-adc2-47835b8c2d88.PNG)
 
 * 실제 데이터가 저장되는 리프노드 (Leaf nodes)
 * 리프노드까지의 경로 역할을 하는 논리프노드 (Non-leaf nodes)
 * 경로의 출발점이 되는 루트노드 (Root node)
 
 B+트리는 리프노드에 이르기까지에 대한 자식 노드에 포인터가 저장되어 있습니다.
 즉, B+트리의 검색은 루트노드에서 어떤 리프 노드에 이르는 한 개의 경로만 검색하면 되므로 매우 효율적입니다.
 
 위와 같은 구조로 인해 B+트리 인덱스는 등가 비교는 물론 범위 검색에도 사용될 수 있습니다.
 
 
 * 등가 비교
    ```
    WHERE key = 123
 
    ```
 * 범위 검색
    ```
    WHERE key BETWEEN 100 AND 200
    ```
    > LIKE 검색의 와일드카드는 전방 일치여야 인덱스 효과를 얻을 수 있습니다.
    ```
    WHERE key LIKE 'foo%'
    ```
    > Leaf node에서 문자열이 사전 순서대로 정렬되어있기 때문에 전방 일치가 아닌 LIKE 검색은 물리적으로 불가능합니다.
 
 
 
 
 

 
 
 
  
 



 
 

 
 
 
 
 
 
 



 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
    
    
    
    
    
    
    
