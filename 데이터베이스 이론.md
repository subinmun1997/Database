# Database 이론

* [관계형 DB에서의 관계](#관계형-DB에서의-관계)

* [Connection pool](#Connection-pool)

* [데이터베이스 시스템 개요](#데이터베이스-시스템-개요)

* [DB 설계 개요](#DB-설계-개요)
  
* [ER 모델 개념적 설계](#ER-모델-개념적-설계)
  
* [관계 모델 논리적 설계](#관계-모델-논리적-설계)

* [트랜잭션(transaction)과 ACID 특성을 보장하는 방법](#트랜잭션(transaction)과-ACID-특성을-보장하는-방법)

* [신뢰성과 회복(Recovery)](#신뢰성과-회복(Recovery))

* [뷰(View)](#뷰(View))

* [정규화 (Normalization)](#정규화 (Normalization))
 
* [인덱스(Index)](#인덱스(Index))
 
</br>

## :bulb: 관계형 DB에서의 관계

 관계형 데이터베이스( MySQL, Oracle, MS-SQL, SQLite 등 )는 엔티티(객체)끼리 관계를 맺을 수 있어서 관계형 DB라는 이름이 붙었습니다. 관계는 두 엔티티가 서로 관련이 있을 때를 말하는데, 다음과 같은 관계를 맺을 수 있습니다.
 * 일대일 (1:1)
 * 일대다 (1:N)
 * 다대다 (N:M)
 
### 1. 일대일 관계(1:1)

   1 : 1 관계란 어느 엔티티 쪽에서 상대 엔티티를 보더라도 반드시 단 하나씩 관계를 가지는 것을 말합니다.
  
   예를 들면, 우리나라에서 결혼제도는 일부일처제입니다.
  즉, 한 남자는 한 여자와, 한 여자는 한 남자와 밖에 결혼을 할 수 없습니다. 
  법적으로 남편을 또는 부인을 2명 이상 둘 수 없습니다.
  이러한 관계를 1:1 관계라고 합니다.
  
  <br>
  
### 2. 일대다 관계(1:N)
  
   1 : M 관계는 한 쪽 엔티티가 관계를 맺은 엔티티 쪽의 여러 객체를 가질 수 있는 것을 의미합니다.
  이 관계는 매우 흔한 방식이며, 실제 DB를 설계할 때 자주 쓰이는 방식입니다.
  
   예를 들면, 부모와 자식 관계라고 생각하시면 됩니다.
  부모는 자식을 1명만 낳을 수도 있고, 2명, 3명, 4명, 10명 그 이상도 낳을수 있습니다.
  DB에서는 이를 부모가 자식을 소유한다고 (has a 관계) 표현합니다.
  반대로 자식 입장에서는 부모(어머니, 아버지의 쌍)를 하나만 가질 수 밖에 없습니다.
  이러한 관계를 1 : N 관계라고 하며, 계층적인 구조로 이해할 수도 있습니다.
  
  <br>
  
### 3. 다대다 관계(N:M)

   N : M 관계는 관계를 가진 양쪽 엔티티 모두에서 1 : M 관계가 존재할 때 나타나는 모습입니다.
  즉, 서로가 서로를 1:N 관계로 보고 있는 것입니다.
  
   예를 들면, 쇼핑몰에서 회원과 상품이 관계를 맺을 수 있습니다.
  한 회원은 쇼핑몰의 여러 상품들을 가질 수 있습니다.
  청바지, 모자, 티셔츠, 남방 등 다 제가 가질 수 있죠.
  반대로 한 티셔츠도 여러 회원들을 가질 수 있습니다.
  하나의 티셔츠를 나도 친구도 부모님도 가질 수 있습니다.
  이처럼 관계를 맺은 두 엔티티가 서로 많이 가질 수 있을 때, 이를 N : M 관계라고 합니다.
  
  <br>
  
### 4. 대표키와 외래키

   table을 각 엔티티를 식별할 수 있는 대표 키(PK, Primary key)가 존재합니다.
  대표키는 중복되지 않는 값입니다. (unique)
  
   예를 들어, 주민 번호는 대한민국 국민들을 식별할 수 있는 대표 키가 됩니다.
  주민등록증이 같은 사람은 있을 수 없기 때문에, 대표 키로서 기능을 할 수 있습니다.
  
  <br>
  
  #### 테이블간의 관계를 맺을 때, 흔히 대표키를 이용하여 관계를 맺습니다.
   예를 들어, 1 : N 관계의 대표적인 예로 게시글과 댓글을 생각해보겠습니다.
  게시글은 여러 댓글들을 가지고 있으며, 댓글은 어떤 한 게시글에만 속해 있습니다.
  따라서 게시글과 댓글은 1:N 관계라 할 수 있습니다.
  
   게시글은 자신이 어떤 댓글들을 가지고 있는지 어떻게 알 수 있을까요?
  댓글 테이블을 설계할 때 컬럼에는 아래와 같은 정보들이 있을 수 있습니다.
  
  * 댓글 아이디(PK)
  * 작성자 명
  * 내용
  * 작성일
  
   여기서 어떤 게시글에 속해 있는지에 대한 정보가 필요하므로 하나의 컬럼이 더 필요한데, 이를 외래키( FK, Foreign key )라 합니다.
  
  * 게시글 아이디(FK)

   여기서 게시글 아이디는 게시글 테이블의 대표 키이며, 이를 댓글 테이블의 외래키로 지정하여 관계를 맺을 수 있습니다.
  
   즉, 게시글은 어떤 댓글들이 자신의 댓글들인지 알 필요 없고, 댓글만 자신이 어떤 게시글에 속하는지만 알면 1:N 관계를 성립할 수 있습니다.
  그 역할이 외래키인 것이죠.

   그렇다면 N:M 관계에서는 어떨까요?
  여기서는 서로가 서로를 1:M , 1:N  관계로 갖고 있기 때문에, 서로의 PK가 자신의 외래키 컬럼으로 갖고 있으면 됩니다.
  일반적으로 N:M 관계는 두 테이블의 대표키를 컬럼으로 갖는 또 다른 테이블을 생성해서 관리합니다.
  
  [ 참고자료 ] <http://www.dbguide.net/db.db?cmd=view&boardUid=12851&boardConfigUid=9&categoryUid=216&boardIdx=40&boardStep=1>

  
  <br>
  
## :bulb: Connection pool
  
### 1. 커넥션 풀(Connection pool)

  커넥션 풀이란 DB와 미리 connection( 연결 )을 해놓은 객체들을 pool( 웅덩이 )에 저장해두었다가, 클라이언트 요청이 오면 커넥션을 빌려주고, 볼일이 끝나면 다시 커넥션을 반납받아 pool에 저장하는 방식을 말합니다.
    
  ![connection](https://user-images.githubusercontent.com/52366841/126592139-6cb3b358-9bf1-426b-8016-0d45ef37fef9.PNG)
    
  클라이언트가 DB와 연결이 필요할 때, connection pool에서 connection을 빌려와 DB에 접근해서 쿼리를 날린 후, 볼 일이 끝나면 사용했던 connection을 다시 pool에 반납을 하는 과정을 표현했습니다.
  
<br>
    
### 2. 특징 / 장단점

 예를 들어, 게시판 웹 애플리케이션을 가정해보겠습니다. 어떤 유저가 게시글을 작성하는 과정을 보면, 그 과정은 다음과 같습니다.
 
 1. 클라이언트가 서버로 게시글 데이터를 전달
 2. 비즈니스 로직 처리
 3. DB와 커넥션을 맺은 후, DB에 게시글 데이터를 저장
 4. DB와 커넥션을 끊고, 비즈니스 로직 처리
 5. 클라이언트에 응답
 
 그런데 서비스가 커져서 유저가 한 명이 아니라, 100명의 유저가 동시에 접속 중이라고 가정해보겠습니다.
위와 같은 경우 매번 DB와 커넥션을 맺고 끊는 과정이 필요한데 커넥션 풀을 사용하게 되면, 미리 연결을 맺고 있는 커넥션들이 있기 때문에 커넥션을 맺고 끊는 과정이 불필요합니다.
즉, DB 접근 시 불필요한 작업(커넥션 생성, 끊기)이 사라지므로 성능향상을 기대할 수 있습니다.

 DB에서는 기본적으로 커넥션을 일정량 제공해줍니다.
그런데 유저가 많아져서 커넥션이 모자랄 경우, 즉 기본으로 제공된 커넥션이 모자랄 경우 원활한 서비스가 이루어지지 않습니다.
커넥션이 반납될 때까지 기다려야 하기 때문이죠. 따라서 유저수에 따라 커넥션을 조절할 필요가 있습니다.

 그렇다고 커넥션을 막 늘리는 것은 좋지 않습니다.
컴퓨터 세계에서는 항상 trade off가 있듯이, 커넥션 풀을 통한 장점도 있지만 단점도 있습니다.
커넥션 또한 객체이므로 메모리를 차지하게 됩니다.
따라서 무작정 많이 늘리는 것은 메모리를 많이 차지하게 되므로 오히려 성능이 떨어지는 결과를 가져옵니다.

<br>

## :bulb: 데이터베이스 시스템 개요

### 1. 정보 시스템

 정보 시스템이란 데이터를 통해 정보를 얻어내는 시스템을 말합니다.
 
 * 데이터
 >현실 세계의 단순한 관찰을 통해 수집된 사실 또는 값
 
 * 정보
 >특정 해석이나 의미를 갖는 데이터
   
   ![info](https://user-images.githubusercontent.com/52366841/126595897-1debe566-f926-46fa-b00f-bf792189a98b.PNG)
   
 * collect
   데이터를 수집하는 행위
   
 * store
   데이터를 조직화(organize)하여 저장하는 행위
   
 * processing
   원하는 정보를 얻기 위해 데이터들을 처리
   
<br>


### 2. 데이터베이스 시스템과 DBMS

#### 1) 데이터베이스 시스템

 collect, processing, organize 등의 작업을 잘할 수 있도록 도와주는 시스템을 말합니다. 데이터베이스는 다음과 같은 특징이 있습니다.
 
 * 여러 사용자들의 공동 접근이 가능해야 한다.
 * 계속적인 변화를 통해 실시간으로 처리할 수 있는 운영 시스템이어야 한다.
 * 메모리 주소가 아닌 내용을 통해 데이터를 참조한다.
 ##### 실시간 접근성 / 계속적인 변화 / 동시 공유성 / 운영 가능 / 내용 참조
 
 <br>

#### 2) DBMS (Database Management System)

 어플리케이션과 시스템에 저장되어 있는 데이터의 중재자로서의 소프트웨어 시스템을 말합니다.
 흔히 알고있는 MySQL. Oracle, MS-SQL등이 DBMS입니다.

 ![db](https://user-images.githubusercontent.com/52366841/126597091-27149c18-2381-4665-bb30-9ab7b77a952c.PNG)
 
 * Meta data
 > 데이터를 위한 데이터로서, 데이터의 정보를 표현하는 데이터
 > ex) 회원의 비밀번호를 하나의 데이터라 할 때, "8~20글자의 영문자, 특수문자 포함"이라는 정보는 비밀번호를 위한 데이터입니다.
 > > 즉, "8~20글자의 영문자, 특수문자 포함"정보가 비밀번호의 Meta data입니다.
 
 <br>
 
### 3. DBMS의 기능

 DBMS는 데이터를 정의, 조작, 제어할 수 있어야 하며, 관계형 데이터베이스 관리 시스템(RDBMS)에서는 데이터를 SQL언어를 통해 다룰 수 있습니다.
 SQL은 다음과 같은 종류로 나눌 수 있습니다.
 
 * DDL (Data Definition Language)
 > 데이터를 정의하는 언어
 
 * DML (Data Manipulation Language)
 > 데이터를 조작하는 언어
 
 * TCL (Transaction Control Language)
 > 데이터의 안정성, 정확성을 유지하는 언어
 > Mutual exclution(상호배제)를 통한 transaction이 서로 방해를 받지 않도록 병행 제어

<br>

## :bulb: DB 설계 개요

### 1. DB설계 방법

 ![dbms](https://user-images.githubusercontent.com/52366841/126608468-40614532-c160-4d27-a9b2-bf8d8fa56078.PNG)
 
 DB 설계 단계는 위의 그림과 같습니다.
 
 1. 실세계 - 요구사항 수집 분석
 > 먼저 실제 세계에서 어떤 시스템을 구축할 것인지에 대한 요구사항을 수집합니다.
 > 요구사항에 대해 어떤 데이터들이 필요한지, 어떤 기능들이 필요한지 분석합니다.
 
 2. 개념적 설계
 > ER 다이어그램을 통해 요구사항을 개념적으로 표현합니다.
 
 3. 논리적 설계
 > 관계 모델(Relation model)을 통해 개념적 설계를 논리적으로 표현합니다.
 
 4. 물리적 설계
 > 실제 디스크와 같은 물리 저장장치에 데이터를 저장할 수 있도록 표현합니다.
 
 이 때, 개념적 설계와 논리적 설계에서 작성하는 ER 다이어그램과 Relation을 표현하는 것은 특정 DBMS에 관계가 없습니다.
즉, MySQL이든 Oracle이든 설계하는 방법이 같다는 의미입니다.
그런데 물리적 설계는 특정 DBMS를 전제로 한 모델링이기 때문에 DBMS에 의존적이어야 합니다.

### 2. DB설계 예시

 예를 들어, "대학교 학사 관리 시스템" DB를 구축한다고 가정해보겠습니다.
앞에서 살펴본 단계에 따라 학사 관리 시스템에는 어떤 정보들이 필요할 지 분석한 후, 개념적 설계 및 논리적 설계하는 방법은 간단하게 살펴보겠습니다.

#### 1) 현실 세계로부터 요구사항을 분석 및 수집

 요구사항을 분석해보니 학생과 교과목에 대한 정보만 있으면 되고, 학생과 교과목에는 다음과 같은 정보들이 있으면 될 것으로 파악되었습니다.
 
 * 학생은 학번, 이름, 학년의 정보를 갖습니다.
 * 과목은 학수번호, 과목명의 정보를 갖습니다.
 
 지금은 이렇게 간단하게 했지만, 요구사항을 파악하는 작업은 굉장히 중요합니다.
 설계를 마쳤는데, 빠진 부분이 있거나 추가해야할 부분이 있다면 설계를 처음부터 다시해야 할만큼 치명적이기 때문입니다.
 
#### 2) 개념적 설계

 개념적 설계는 ER 다이어그램 (Entity Relationship Diagram)을 통해 모델링하는 단계입니다.
 
 학생1, 학생2, 학생3을 각각 하나의 객체(Entity)라고 할 때, 각 객체들이 공통적으로 갖는 데이터 항목을 Entity type이라고 합니다.
 
 ![entity](https://user-images.githubusercontent.com/52366841/126612266-dd07b8d5-4d18-4cc6-9414-f137a9f4db1b.PNG)
 
 ER 다이어그램은 객체간의 관계 (Entity Relation)를 표현한 것으로서, 위에서 예로 든 "학사 관리 시스템"을 ER 다이어그램으로 표현하면 아래와 같습니다.
 
 ![takes](https://user-images.githubusercontent.com/52366841/126613107-0c9fbb58-39b8-4dbe-aa2b-86cfd52e254c.PNG)
 
 Takes는 학생이 강의를 수강한다는 관계를 표현한 것으로서, 이를 Relationship Type이라고 합니다.
 이렇게 객체간의 관계를 다이어그램으로 표현한 것을 ER 다이어그램이라 하며, 이 단계를 개념적 설계 단계라고 합니다.
 
#### 3) 논리적 설계

 논리적 설계는 개념적 설계에서 표현한 ER 다이어그램을 테이블로 표현하는 단계를 말합니다.
 여기서 말하는 테이블은 행과 열이 있는 표를 의미합니다. 
 SQL을 작성하기 위한 테이블 정의라고 보면 됩니다.
 
 "학사 관리 시스템"에서 ER 다이어그램을 바탕으로 논리적 설계를 해보면 다음과 같습니다.
 
 ![학사관리](https://user-images.githubusercontent.com/52366841/126613603-fd0ee988-ccbb-4fdd-9caf-15271b0f2b5a.PNG)
 
 각 Entity가 테이블로 대응됐고, Relationship Type도 테이블로 표현됐습니다.
 
#### 4) 물리적 설계

 이제 테이블의 구조, 즉 스키마가 정리됐으니 사용하는 DBMS의 SQL로 테이블을 생성해야 합니다.
 MySQL의 경우 Student 테이블을 다음과 같은 명령어로 생성할 수 있습니다.
 
 ```
 CREATE TABLE Student (
  student_no INT NOT NULL AUTO INCREMENT PRIMARY KEY,
  student VARCHAR(30) NOT NULL,
  year int NOT NULL
 );
 
 ```
 
 
## :bulb: ER 모델 개념적 설계

### 1. ER 모델 (Entity Relation Model)

 ER 모델은 요구사항으로부터 얻어낸 정보들을 개체(Entity), 애트리뷰트(Attribute), 관계성(Relation)으로 기술하는 데이터 모델을 말합니다.
 
 ![er](https://user-images.githubusercontent.com/52366841/126725614-10255902-c7f0-48d7-ab15-7a72edf3cb6b.PNG)
 
 * 개체 (Entity)
 > 개체란 단독으로 존재하는 객체를 의미하며, 동일한 객체는 존재하지 않습니다.
 > > 예를 들어, 학생 정보가 학번, 이름, 학년이 있을 때, 3개의 정보가 모두 같은 학생이 오직 한 명이면 이를 개체라고 합니다.
 > > 즉, 학생 한명이 개체가 되는 것입니다.
 
 * 애트리뷰트, 속성 (Attribute)
 > 개체가 갖는 속성을 의미합니다.
 > > 예를 들어, Student에서 학번, 이름, 학년 같은 정보를 속성이라 합니다.
 > ER 다이어그램에서 Attribute는 원으로 표현합니다.
 
 * 관계 (Relation)
 > Entity Type간의 관계를 의미합니다.
 > > 예를 들어, 수강을 뜻하는 Takes는 학생과 과목간의 "수강"이라는 관계를 갖습니다.
 > > 이 때, Takes를 Relation Type이라 하며, Relation Type 역시 속성을 가질 수 있습니다.
 > ER 다이어그램에서 Relation은 마름모로 표현합니다.
 
 ER 다이어그램을 구성하는 요소는 위와 같습니다.
 이제부터 ER 다이어그램을 그리기 위한 각 요소들을 표현하는 방법에 대해 알아보도록 하겠습니다.
 
### 2. 애트리뷰트 (Attribute)

#### 1) Attribute Domain

 * 해당 Attribute가 가질 수 있는 집합(도메인)을 말합니다.
 * 예를 들어,
 > 학생의 학년을 뜻하는 year 애트리뷰트는 1,2,3,4 와 같은 숫자만 허용하므로 year의 Arrtibute Domain은 정수형(integer)입니다.
 > 학생의 이름을 뜻하는 name 애트리뷰트는 문자열이어야 하므로 name의 Attribute Domain은 문자열(String)입니다.
 
#### 2) 키 애트리뷰트 (Key Attribute) 

 * 다른 객체들과 중복되지 않는 고유한 값을 가진 Attribute로서, 주로 객체를 식별하는데 사용되는 Attribute입니다.
 * 예를 들어, 학생의 학번을 의미하는 Student_no는 다른 학생들과 중복되지 않는 고유한 번호입니다.
 > 따라서 Student_no는 Key Attribute 입니다.
 * Key Attribute를 ER 다이어그램에서는 원에 밑줄로 표시합니다.
 
 ![key](https://user-images.githubusercontent.com/52366841/126726539-d102eb8c-d394-4f2e-9fdd-09a0f5c24880.PNG)
 
#### 3) 복합 애트리뷰트 (Composite Attribute) 
 
  * 독립적인 Attribute들이 모여서 생성된 Attribute를 의미합니다.
  * 예를 들어, 학생의 주소를 나타내는 Address 애트리뷰트가 있을 때, 우리나라에서 주소는 "경기도", "OO시", "OO동", "OO아파트"와 같이 표현합니다.
  > 즉, Address는 위의 4개의 독립된 Attribute가 모여서 생성된 Attribute이므로 Address를 Composite Attribute라고 합니다.
  
  ![compo](https://user-images.githubusercontent.com/52366841/126728116-c130ffcd-7cc1-41f2-919c-23f2dd9a8e76.PNG)

#### 4) 다중값 애트리뷰트 (Multi-Valued Attribute)

 * 하나의 Attribute가 여러 개의 값을 가지는 Attribute를 의미합니다.
 * 예를 들어, 학생의 전공을 나타내는 Degree Attribute가 있을 때, 이 학생이 복수 전공을 할 경우 Degree Attribute 값이 2개가 되므로, 이 때 Degree Attribute를 Multi-Valued Attribute라고 합니다.
 * 이와 달리, 오직 하나의 값을 갖는 애트리뷰트를 단일값 애드리뷰트 (Single-Valued Attribute)라고 합니다.
 * Multi-Valued Attribute는 ER 다이어그램에서 두 개의 원으로 표현합니다.
 
 ![multi](https://user-images.githubusercontent.com/52366841/126728371-cf1d6074-7512-4d6e-b711-9b740cb1a52d.PNG)
 
#### 5) 유도된 애트리뷰트 (Derived Attribute)

 * 다른 Attribute가 갖고 있는 값으로부터 계산되어져 나온 Attribute를 의미합니다.
 * 예를 들어, 모든 상품의 총 가격을 나타내는 total, 상품의 가격을 나타내는 price, 상품의 개수를 나타내는 count Attribute가 있다고 가정하겠습니다.
 > total은 price와 count의 곱으로 계산되어져 나오는 값이므로 total Attribute는 Derived Attribute입니다.
 * Derived Attribute는 ER 다이어그램에서 원을 점선으로 표현합니다.
 
 ![derived](https://user-images.githubusercontent.com/52366841/126728705-ff94c752-0ae8-4330-a4d7-7b0a805c047e.PNG)
 
### 3. 관계성 (Relationship)

 ER 다이어그램을 설계하는 가장 큰 목적은 Entity Type을 정의하고 Entity Type간의 관계를 표현하는 것입니다.
 Attribute를 통해 Entity Type을 정의했다면, Relationship을 통해 Entity Type간의 관계를 표현합니다.
 
 관계성은 2가지 제약조건을 명시함으로써 표현할 수 있습니다.
 
#### 1) 카디널리티 비율 제약조건 (Cardinality Ratio Constraint)

 관계를 맺는 두 Entity Type에 대해, 한 개체가 얼마나 많은 다른 개체와 관련될 수 있는지를 나타내는 제약조건을 뜻합니다.
 
 * 일대일 (1:1)
 > 두 개 Entity Type의 개체들은 서로 일대일로 대응
 
 * 일대다 (1:N)
 > 하나의 개체가 다른 Entity Type의 많은 개체들과 관련되지만, 그 역은 성립하지 않음

 * 다대다(N:M)
 > 하나의 개체가 다른 Entity Type의 많은 개체들과 관련되며, 역이 성립
 
 예를 들어, "학사 관리 시스템"에서 한 학생은 많은 과목을 수강할 수 있고 한 과목에는 많은 학생이 수강하므로, Student Entity Type과 Course Entity Type은 N:M 관계입니다.
 이러한 카디널리티 비율제약조건을 ER 모델에 표현하면 다음과 같이 N, M을 명시해줘서 표현합니다.
 
 ![TYPE](https://user-images.githubusercontent.com/52366841/126730715-ca4f8e47-12f6-4922-b800-bcaeb9026a22.PNG)
 
 또 다른 예시로, 부모와 자식 Entity Type 관계에서 부모는 많은 자식을 가질 수 있지만 자식은 한 부모만 가질 수 있습니다.
 즉, 부모와 자식은 1:M 관계이며, 이를 ER 다이어그램으로 다음과 같이 표현할 수 있습니다. 
 M에 해당하는 Entity Type에 M을 명시해주면 됩니다.
 
 ![1m](https://user-images.githubusercontent.com/52366841/126731249-89580dde-3df8-454b-86bf-b3d397bd8095.PNG)
    
#### 2) 참여 제약조건 (Participation Constraint)

 관계를 맺는 두 Entity Type에 대해 한 개체의 존재가 다른 개체의 존재에 의존하는지 여부를 나타내는 제약조건을 뜻합니다.
 
 * 전체 참여 (Total Participation)
 > 하나 또는 그 이상의 개체가 참여
 
 * 부분 참여 (Partial Participation)
 > 선택적인 참여
 
 예를 들어, 학생은 과목을 꼭 수강 할 필요가 없지만 과목은 항상 수강생이 있어야 합니다.
 수강생이 없는 과목은 폐강되기 때문입니다.
 
 ER 모델에서 전체 참여는 두 개의 실선으로 부분 참여는 한 개의 실선으로 표현하고, 이를 표현하면 다음과 같습니다.
 
 ![partici](https://user-images.githubusercontent.com/52366841/126731583-f72d540c-0a88-4d33-bfd5-a901632092a8.PNG)
 
#### 3) 구조적 제약조건 (Structural Constraint)

 앞서 살펴 본 두 개의 제약조건을 가리켜 구조적 제약조건이라 합니다.
 구조적 제약조건은 관계를 맺는 두 Entity Type에 1, N, M을 표시하거나 한 줄 또는 두 줄을 표시하지 말고 (MIN,MAX)방식으로 두 제약조건을 한 번에 표현하는 방식입니다.
 
 예를 들어, 학생은 최소 3개, 최대 6개의 강의를 수강할 수 잇으며, 강의는 최소 10명 최대 100명의 학생들이 들을 수 있을 때, 이를 ER 다이어그램으로 표현하면 다음과 같습니다.
 
 ![STRUCT](https://user-images.githubusercontent.com/52366841/126731844-f7158a71-f33a-447a-b9d7-87afe08760c5.PNG)
 
 지금까지 여러 애트리뷰트와 관계성의 두 가지 제약조건의 개념, 그리고 이를 ER 다이어그램에서 어떻게 표현하는지에 대해 알아보았습니다.
 이 내용들을 정리하면 아래 그림과 같습니다.
 
 ![SYMBOL](https://user-images.githubusercontent.com/52366841/126731928-92c5fade-e147-4226-837d-c54a68a83cd8.PNG)
 
#### 4) 약한 개체 (Weak Entity)와 식별 관계성 타입 (Identifying Relationship Type)

 약한 개체란 자신의 Key Attribute가 없는 Entity Type을 뜻합니다.
 
 예를 들어 "학사 관리 시스템"에서 강의번호 10043는 10043-01, 10043-02와 같이 여러 개의 분반이 있을 수 있습니다.
 이 때 분반이라는 개체는 자신의 Key Attribute가 없고, 강의 테이블에 의존하기 때문에 약한 개체라 합니다.
 다시 말하면 분반이 존재하기 위해서는 꼭 Course Entity Type이 있어야 합니다.
 
 강의와 분반의 관계를 ER 다이어그램으로 표현하면 다음과 같습니다.
 
 ![bunban](https://user-images.githubusercontent.com/52366841/126732196-23e492e5-764e-470a-8f26-5be9a4de3e8d.PNG)
 
 ER 다이어그램에서는 약한 개체는 두 개의 네모로 표현하고, 약한 개체의 key인 bun_no를 partial key (부분 키)라고 합니다.
 부분 키는 단독으로 존재할 수 없고 자신을 소유하고 잇는 Owner Entity Type인 Course Entity type의 key와 합쳐서 표현되어야 합니다.
 ER 다이어그램에서 부분 키는 점선으로 된 밑줄로 표현합니다.
 
 또한 Entity type이 약한 개체와 관계를 맺을 때는 식별 관계성 타입으로 표현하고, ER 다이어그램에서 두 개의 마름모로 표현합니다.
 약한 개체는 항상 의존적이기 때문에 참여 제약 조건은 전체 참여 (total participation)입니다.
 
 <br>
 
## :bulb: 관계 모델 논리적 설계

### 1. 관계 모델 (Relation Model)

 관계형 모델은 실제 세계의 데이터를 관계라는 개념을 사용해 표현한 데이터 모델입니다.
 데이터 모델이란 "~라는 개념을 사용해 데이터를 표현해주세요" 라고 정의하는 것을 말하며, 관계형 모델은 그중에 하나라고 할 수 있습니다.
 Mongo DB 같은 KVS (Key-Value Store)도 데이터 모델의 하나라고 볼 수 있습니다.
 
 관계형 모델은 수학의 집합론에 근거한 모델이며, 릴레이션(테이블)의 연산을 술어논리로 표현할 수 있어야 합니다.
 SQL과 관계형 모델을 동일시 여기는 경우가 있는데, 이 둘은 다른 개념입니다.
 그렇기 때문에 관계형 모델과 SQL에서 사용하는 용어도 다릅니다.
 
 관계 모델은 관계형 데이터베이스에 직접 구현할 수 있도록 DB구조를 정의하는 방법을 제공합니다.
 쉽게 테이블을 설계하는 과정이라고 생각하면 되고, ER 다이어그램을 기반으로 작업하는 것이 순서입니다.
 
 관계 모델은 릴레이션의 관계를 표현하는 것입니다.
 아래는 관계 모델의 핵심인 릴레이션에 대한 예시입니다.
 
 ![relation](https://user-images.githubusercontent.com/52366841/126738454-198e9d1d-75e2-4074-b03f-3534d6369b2d.PNG)
 
 * 릴레이션 (Relation)
 > 개체를 표현하기 위한 데이터 구조로써 2차원 테이블로 표현하며, heading(스키마)와 body(본체)로 구성되어 있습니다.
 > > heading은 속성(attribute)이 n개가 모인 집합이며, 이름과 데이터형으로 구성되어 있습니다.
 > > body는 속성값의 집합인 튜플(tuple)의 집합입니다.
 > SQL의 테이블과 대응됩니다.
 
 * 튜플 (Tuples)
 > 하나의 개체를 의미하고 Relation에서 행으로 표현하며, 이를 릴레이션 상태(Relation State)라고도 합니다.
 > 각 튜플은 유일해야 한다는 특징이 있습니다.
 > SQL의 row와 대응됩니다.
 
 * 애트리뷰트 (Attribute)
 > 개체의 속성들을 의미하며 Relation에서 열로 표현
 > SQL의 column과 대응됩니다.
 
 이를 정리하면, 릴레이션은 튜플의 모임이고, 릴레이션의 관계를 정의한 것이 관계 모델입니다.
 관계 모델은 릴레이션 단위로 다양한 연산을 사용해 질의를 수행하는 데이터 모델입니다.
 

### 2. 제약 조건

 관계 모델이 정의되기 위해서는 몇 가지의 제약 조건이 있습니다.
 
 
#### 1) 무결성 제약 조건 (Integrity constraints)

한 객체에 저장되는 데이터를 제한하는 조건을 말합니다.

* 도메인 제약 조건
> 각 튜플의 애트리뷰트는 도메인에 속하는 값이어야 합니다.
> 즉, 도메인이 Integer면 Integer 값만 저장될 수 있습니다.

* 엔티티 무결성 제약 조건
> 기본 키 값은 NULL이 될 수 없습니다.

* 참조 무결성 제약 조건
> 어떤 릴레이션 A의 튜플이 다른 릴레이션 B의 튜플을 참조하려면, 참조하려는 그 튜플은 B 릴레이션 내에 존재해야 합니다.
> 외래 키 (Foreign Key)는 참조 무결성 제약조건을 만족해야 합니다.
> > 외래 키 : 다른 릴레이션의 key 애트리뷰트를 참조하는 애트리뷰트


#### 2) 키 제약 조건

 서로 다른 튜플은 동일한 키 애트리뷰트를 갖지 않아야 한다는 조건을 말합니다.

### 3. ER 모델을 관계 모델로 변환

 관계 모델은 ER 모델을 기반으로 설계됩니다.
 개념적 설계인 ER 모델을 논리적 설계인 관계 모델로 바꾸는 방법은 다음과 같습니다.

#### 1) 일반적인 변환

 ![변환1](https://user-images.githubusercontent.com/52366841/126741048-827115e7-e8d2-46d2-af57-3c71607a225d.PNG)
 
 일반적으로 ER 모델과 Relation은 다음과 같이 대응됩니다.
 
 * 하나의 Entity는 한 개의 Relation으로 대응
 * Entity가 가지고 있는 Attribute들은 Relation의 Attribute로 대응
 * Relation Entity인 Takes 역시 하나의 Relation으로 표현

 이것이 ER 모델을 Relation으로 변환하는 일반적인 방법입니다.
 
 지금부터 ER 모델의 특별한 Attribute에 대해서 ER 모델을 Relation모델로 변환할 때의 주의점, 또 두 Entity간의 관계성에 따라 릴레이션의 수를 줄일 수 있는 방법에 대해 알아보도록 하겠습니다.
  
#### 2) 복합 Attribute

 복합 Attribute을 구성하고 있는 독립된 Attribute들을 나눠서 관계 모델의 Attribute로 작성합니다.
 
 ![복합](https://user-images.githubusercontent.com/52366841/126741942-b593a60c-9a08-4922-b3c5-f6d9475ed89c.PNG)
 
 ER 모델의 복합 Attribute인 Address를 구성하고 있는 do, si, dong, apartment Attribute들은 관계 모델로 변환할 때 일반적인 단일 Attribute처럼 취급합니다.
 
#### 3) 약한 개체 (Weak Entity)

 ER 모델에서 약한 개체는 독립적으로 존재할 수 없고 Owner Entity Type에 종속적입니다.
 그런데 관계 모델로 변환할 때는 약한 개체를 독립된 Relation으로서 작성해야 합니다.
 
 ![weak](https://user-images.githubusercontent.com/52366841/126742183-eb0adac9-9f0d-4aef-938c-31589a3c989a.PNG)
 
 bunban Entity는 약한 개체로서 Course에 종속적입니다.
 약한 개체인 bunban을 ER 모델에서 Relation으로 변환할 때는 하나의 Relation으로 표현합니다.
 이 때 주의할 것은 bunban Relation의 Attribute에 Owner Entity Type인 Course Entity의 key가 Attribute로 추가된다는 것입니다.
 즉, bunban Relation의 속성에는 course_no가 추가됩니다.
 
#### 4) 유도된 Attribute

 ER 모델의 유도된 Attribute는 Relation 모델에서는 생략됩니다.
 
 ![유도](https://user-images.githubusercontent.com/52366841/126742508-ea1b97c5-4e95-4fa6-8f35-4477929a9724.PNG)
 
 상품 가격의 총합을 나타내는 total Attribute는 price와 count에 의해 계산되어진 유도된 Attribute입니다.
 유도된 Attribute는 ER 모델에서 Relation으로 변환할 때 Attribute로 추가되지 않습니다.
 그래서 변환된 Relation에는 total이라는 Attribute가 없습니다.
 
#### 5) 다중값 Attribute

 다중값 Attribute의 각 Attribute 값들은 Relation에서 하나의 튜플이 됩니다.
 
 ![다중값](https://user-images.githubusercontent.com/52366841/126743337-af62e87e-a013-4694-9f7f-d1b2d5a48f44.PNG)
 
 Student Entity에 friends라는 다중값 Attribute가 있을 때,
 왼쪽 릴레이션처럼 다중값 Attribute를 하나의 튜플안에 표현하는 것이 아니라,
 오른쪽 릴레이션처럼 friends의 각 값들이 각각 하나의 튜플이 되어 작성되어야 합니다.
 
 참고로 이렇게 중복을 없애는 작업을 정규화라고 합니다.
 
 앞서 일반적인 변환에서 ER 모델의 Relation Type을 관계 모델로 변환을 할 때 별도의 릴레이션을 작성해야 한다고 했었습니다.
 그 이유는 두 Entity가 관계를 맺고 있다는 것을 두 Entity의 primary key를 Attribute로 하는 하나의 릴레이션으로 만듦으로써 표현할 수 있기 때문입니다.
 그러나 릴레이션이 많아지는 것은 연산이 복잡해진다는 것을 의미하기 때문에 릴레이션의 수를 줄이는 것이 좋습니다.
 
 Relationship으로는 1:1, 1:N, M:N이 있으며 어떤 경우에는 ER 모델의 Relation Type이 관계 모델로 변환될 때 생략될 수 있습니다.
 물론 다른 방법으로 두 Entity의 관계를 표현합니다.
 이제 Relationship의 각 경우에 대해 ER 모델을 관계 모델로 변환할 때의 주의사항을 알아보겠습니다.
 
#### 6) 1:1 관계

 어떤 두 Entity의 관계성이 1:1 관계일 때 ER 모델의 Relation Type을 관계 모델로 변환을 할 경우, Relation Type에 해당하는 릴레이션을 따로 만들지 않고, 한 쪽의 Entity에 다른 Entity의 primary key와 Relation Type의 Attribute들을 Attribute로 추가합니다.
 
 예를 들어, Employee Entity Type에 e_no가 101~105인 개체 5개가 있고, Store Entity Type에 s_no가 101~103인 개체 3개가 있다고 해보겠습니다.
 
 두 Entity를 어느 한 쪽으로 합쳤을 때의 결과를 보면 다음과 같습니다.
 
 ![onetoone](https://user-images.githubusercontent.com/52366841/126918776-a61dee5d-f134-4620-8476-2f740c696a18.PNG)
 
 Employee 릴레이션에 manage의 startDate 애트리뷰트, Store의 primary key인 s_no를 추가할 경우 왼쪽 릴레이션과 같고,
 Store 릴레이션에 manage의 startDate 애트리뷰트, Employee의 primary key인 e_no를 추가할 경우 오른쪽 릴레이션과 같습니다.
 두 방식의 차이점은 null이 있느냐 없느냐 입니다.
 Employee의 경우 Store와 관계를 맺지 않고 있는 튜플이 많이 있기 때문에, Employee에 합칠 경우 관계를 맺지 않는 개체에 대해서 null값이 생성됩니다.
 반면 Store쪽으로 합칠 경우에는 null이 생성되지 않습니다.
 
 null이 적게 생기는 릴레이션 쪽으로 Attribute를 추가하는 것이 좋습니다.
 즉, 1:1 관계일 때 ER 모델을 관계 모델로 변환하는 방법은 
 
 * Relation Type에 해당하는 릴레이션을 생성하지 않는다.
 * 원래 Relation Type에 있어야 할 Attribute들을 관계를 맺는 두 릴레이션 중 한쪽으로 합친다.
 > 합칠 때 null이 적게 생기는 경우를 선택하여 합친다.
 
#### 7) 1:M 관계

 1:M 관계에서도 마찬가지로 Relation Type에 해당하는 릴레이션을 생성하지 않고 릴레이션을 합칩니다.
 
 ![onetomany](https://user-images.githubusercontent.com/52366841/126919241-a43a7bfe-ea97-44c1-b686-95c9f8b6455c.PNG)
 
 부모(parent)는 많은 자식(Children)을 가질 수 있고 자식은 한 부모를 가지므로, 부모와 자식은 1:M 관계입니다.
 이 경우 ER 모델을 관계 모델로 변환할 때, Many에 해당하는 릴레이션 쪽으로 Attribute들을 합칩니다.
 즉, parent, relate의 Attribute들이 모두 children으로 합쳐집니다.
 이렇게 합치는 이유 역시, null이 적게 생기기 때문입니다.
 
#### 8) N:M 관계

 N:M 관계는 앞에서 소개했던 일반적인 경우처럼, 관계를 맺는 두 Entity의 primary key를 가져와서 하나의 릴레이션을 생성합니다.
 즉, 기존의 두 엔티티가 릴레이션으로 변환되고, primary key를 가져와 하나의 릴레이션을 생성하여 총 3개의 릴레이션이 생깁니다.
 
 <br>
 
## :bulb: 트랜잭션(transaction)과 ACID 특성을 보장하는 방법

### 1. 트랜잭션 (transaction)

 트랜잭션이란 질의(Query)를 하나의 묶음 처리해서 만약 중간에 실행이 중단됐을 경우, 처음부터 다시 실행하는 Rollback을 수행하고, 오류없이 실행을 마치면 commit을 하는 실행 단위를 의미합니다.
 즉, 한 번 질의가 실행되면 질의가 모두 수행되거나 모두 수행되지 않는 작업수행의 논리적 단위입니다.
 
 예를 들어, 친구에게 인터넷 뱅킹으로 10,000원을 송금하는 상황을 가정해보겠습니다.
 제가 친구에게 송금을 한다면, 저의 계좌에서 10,000원을 차감하고 친구의 계좌에 10,000을 증가시켜야 하는데,
 알 수 없는 오류로 인해 저의 계좌에서는 10,000원이 줄었지만 친구 계좌에는 10,000원이 증가되지 않는다면 어떻게 될까요?
 저의 10,000원은 그냥 공중으로 증발해버리는 문제가 발생합니다.
 이러한 경우가 생기지 않도록 중간에 오류가 발생하면 다시 처음부터 송금을 하도록 하는 것이 rollback입니다.
 오류 없이 정상적으로 송금이 됐다면 정상적으로 실행이 끝났으므로 commit을 합니다.
 즉, 송금 과정을 하나의 트랜잭션이라 볼 수 있습니다.
 
 참고로 트랜잭션을 작업수행의 논리적 단위라고 했는데요, 때문에 DBMS의 성능은 초당 트랜잭션의 실행 수(TPS: Transaction per second)로 측정합니다.
 
#### 트랜잭션 사용 이유

 트랜잭션은 DB 서버에 여러 개의 클라이언트가 동시에 액세스 하거나 응용프로그램이 갱신을 처리하는 과정에서 중단될 수 있는 경우 등 데이터 부정합을 방지하고자 할 때 사용합니다.
 부정합이 발생하지 않으려면 프로세스를 병렬로 처리하지 않도록 하여 한 번에 하나의 프로세스만 처리하도록 하면 되는데, 이는 효율이 너무 떨어집니다.
 즉, 병렬로 처리할 수 밖에 없는 현실적인 상황으로 인해 부정합을 방지하고자 트랜잭션을 사용하는 것입니다.
 트랜잭션에서 중요한 것은 스케줄 관리입니다.
 

### 2. 특성
 
 
 
 



 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
    
    
    
    
    
    
    
